# 前端跨域方案

同源策略：协议相同、域名相同、端口相同

同源策略可以防止其他源获取当前网页的 cookie 等隐私数据，_提交表单不受同源策略限制_

同源限制的行为：

1. cookie、LocalStorage、IndexDB

2. DOM 无法获得

3. ajax 请求不能得到响应结果

> cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。当网页一级域名相同，二级域名不同的时候，浏览器允许通过设置 domain 共享 cookie

### 一级域名相同，不同二级域名 iframe 解决方案

```html

<!-- // 主页面 rm.dev.com:5500/index.html  -->
<iframe src="http://dd.dev.com:5500/a.html" frameborder="0"></iframe>
<script>
    window.name=1234555
    document.cookie = 'a=1;'
    document.domain= 'dev.com'
    setTimeout(()=>{
        $('.inspect').append("<div class='hide'>我是后追加进来的元素</div>")
    }, 2000)
</script>

<!-- iframe 页面  -->
<body>
    <div class="hide"></div>
    我是 a

    <script>
        document.domain= 'dev.com'
        console.log(window.parent.sessionStorage.getItem('__Anubis'))
        console.log(window.parent.document.cookie)
    </script>
</body>
</html>

```

另外，服务器也可以在设置 cookie 的时候指定 cookie 所属的域名为一级域名

### iframe + hash 模式

通过一个中间的同源 iframe 来实现跨域数据交换，但是这样的缺点是，传递的数据会显示的在 URL 上展示

```html
<!-- 主页面 -->
<h1>通过hash传递数据</h1>
<iframe
  src="http://xmind.net:5500/docs/js%E7%B2%BE%E7%B2%B9/demo/cross-origin/iframe-diffrent-origin/a.html"
  frameborder="0"
></iframe>
<script>
  document.querySelector("h1").onclick = function () {
    let iframe = document.querySelector("iframe");
    let hashIndex = iframe.src.indexOf("#");
    iframe.src =
      hashIndex > -1
        ? iframe.src.slice(0, hashIndex) + "#" + Math.random()
        : iframe.src + "#" + Math.random();
  };
  function hashCallback(msg) {
    console.log(msg, "最终得到的数据");
  }
</script>

<!-- 非同源页面 -->
<h1>我是中间页面</h1>
<iframe
  src="http://a.dev.com:5500/docs/js%E7%B2%BE%E7%B2%B9/demo/cross-origin/iframe-diffrent-origin/b.html"
  frameborder="0"
></iframe>
<script>
  window.onhashchange = function () {
    let { hash } = window.location;
    console.log(hash, "不同源页面");
    if (hash) {
      let iframe = document.querySelector("iframe");
      let hashIndex = iframe.src.indexOf("#");
      iframe.src =
        hashIndex > -1
          ? iframe.src.slice(0, hashIndex) + "#" + Math.random()
          : iframe.src + "#" + Math.random();
    }
  };
</script>

<!-- 中间的同源页面 -->
<h1>同源的另一个页面</h1>
<script>
  console.log(window.parent.parent);
  window.onhashchange = function () {
    let { hash } = window.location;
    console.log(hash, "同源页面");
    if (hash) {
      window.parent.parent.hashCallback(hash + "---最终返回去的值--");
    }
  };
</script>
```

### window.name + iframe

window.name 的值再不同的页面（包括不同域名）加载后依然存在，并且支持的数据量非常可观，最大 2MB
简单来说就是页面刷新之后，window.name 值依旧存在

### 使用 postmessage

- [postmessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage) (postmessage 可以是 iframe 也可以是当前窗口打开的另一个窗口)

  ```html
  <!-- 主页面 -->
  document.body.onclick= function(){ window.frames[0].postMessage({a: 1234},
  '*') }
  <!-- // 子页面 -->
  <script>
    function receiveMessage(event) {
      console.log(event.data, 2222, event);
      event.source.postMessage("ok");
    }

    window.addEventListener("message", receiveMessage, false);
  </script>
  ```

- websocket

- jsonp

  ```js
  function callback(res) {
    console.log(res); //接口返回值
  }

  let jsonp = document.createElement("script");
  jsonp.src =
    "http:/www.monkey.com/admin/getUser?name=小燕子&callback=callback";

  document.getElementsByTagName("head")[0].appendChild(jsonp); //添加到页面中

  jsonp.remove(); //从页面中移除

  // getUser 接口返回
    res.writeHead(200,{'Content-Type':'text/javascript'});
    res.write(callback+'('+JSON..stringify(response) + ')');
  ```

- 片段识别符 hash ，子窗口通过监听 hashchange 来展示不同内容

- [window.name](https://www.zhangxinxu.com/wordpress/2019/09/window-name/) 无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就能获取到它

- script 标签、link (background)、form、img（不在同源策略中）

- Access-Control-Allow-Origin
- server proxy（eg. nginx）
