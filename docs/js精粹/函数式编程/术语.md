# 函数式编程 术语

- 函数式编程
    - 总是接受一个参数
    - 必须有返回值
    - 函数依据接收的参数，而不是外部环境运行
    - 对于给定的输入只会有唯一的输出
    - 不是用函数来编程！！！主旨：将复杂的函数合成简单的函数，尽量写成一系列嵌套的函数调用
    - 通俗写法`function x(){}`区别开函数和方法；函数不能归属某个对象，可以直接调用
        ```js
            // 函数式编程
            function a(){}
            class {
                b(){

                }
            }

            // 不是函数式编程
            var a ={
                b(){}
            }
            b.c = function(){}
        ```
    - 函数是一等公民。（first class）
        - 可以赋值给其他变量
        - 可以作为参数
        - 或者作为别的函数的返回值
    - 不可改，变量。
        - 函数式编程中，变量被函数代替
        - 变量仅仅代表某个表达式
        - 所有的变量只能被赋值一次
    - map 和 reduce 是最常用的方法
- 总结
    1. 函数式“第一等公民”
    2. 只用表达式，不用“语句” （没有if switch）
    3. 没有“副作用” 
    4. 不修改状态
    5. 引用透明（函数运行只靠参数，且相同的输入总是得到相同的输出）
        ```js
        identity = i => { return i } 
        // 调用函数 identity(1) 可以直接被 1 替换掉，这个过程被称为替换模型

        ```

## 专业术语

- 纯函数

    - 函数不依赖外部环境的状态
    - 相同的输入总是相同的输出
       ```js
       // 这个函数依赖了外部的 num， 所以不是存函数
        var num = 5;
        function a (b){
            return b> num
        }
        // 变量只能传入进去
        function b(a, b){
            return a>bß
        }
       ```

- 幂等性

执行过无数次后，还具有相同的效果

同一参数，执行1次与执行 2次的结果一致

- 偏应用函数（partial application）

传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

```js
// 带一个 ‘函数参数’ 和 ‘该函数的部分参数’
const partial = (f, )

```
    
    - 柯里化
        - 柯里化通过偏应用函数来实现。他是把一个多参数函数转换为一个嵌套一元函数的过程
        - 柯里化是一种“预加载”函数的方法，这是一种对函数的缓存，是一种高效的编程方法

        ```js
        // 改造硬编码函数
        var checkage = age => age > 18
        // 改造后
        var checkage = min => (age => age > min)
        var checkage18 = checkage(18)
        checkage18(30)

        // 另一个柯里化的例子
        function add(a, b){
            return a + b
        }
        add(1, 2)

        // 柯里化
        function addX (a){
            return function(b){
                return a + b
            }
        }
        add(2)(3)
        ```

    - 柯里化和偏应用函数的区别
        - 柯里化函数的参数是从左向右的
        - 偏应用函数不关心参数的位置，偏应用函数中使用了占位符

        柯里化的参数列表是从左向右的，如果使用 setTimeout 这种就得额外的封装
        ```js
        const setTimeoutWrapper = (time, fn)=> setTimeout(fn, time)
        const delay10 = curry(setTimeoutWrapper)(10)
        delay10(()=> console.log("task one"))
        delay10(()=> console.log("task two"))

        ```
    - setTimeoutWrapper 显得多余，这时我们就可以使用偏函数。
    使用 curry 和 partial 是为了让函数参数或函数设置变得更加简单和强大。
    curry、partial 实现可以参考 lodash