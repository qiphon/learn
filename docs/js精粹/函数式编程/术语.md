# 函数式编程 术语

- 函数式编程
    - 总是接受一个参数
    - 必须有返回值
    - 函数依据接收的参数，而不是外部环境运行
    - 对于给定的输入只会有唯一的输出
    - 不是用函数来编程！！！主旨：将复杂的函数合成简单的函数，尽量写成一系列嵌套的函数调用
    - 通俗写法`function x(){}`区别开函数和方法；函数不能归属某个对象，可以直接调用
        ```js
            // 函数式编程
            function a(){}
            class {
                b(){

                }
            }

            // 不是函数式编程
            var a ={
                b(){}
            }
            b.c = function(){}
        ```
    - 函数是一等公民。（first class）
        - 可以赋值给其他变量
        - 可以作为参数
        - 或者作为别的函数的返回值
    - 不可改，变量。
        - 函数式编程中，变量被函数代替
        - 变量仅仅代表某个表达式
        - 所有的变量只能被赋值一次
    - map 和 reduce 是最常用的方法
- 总结
    1. 函数式“第一等公民”
    2. 只用表达式，不用“语句” （没有if switch）
    3. 没有“副作用” 
    4. 不修改状态
    5. 引用透明（函数运行只靠参数，且相同的输入总是得到相同的输出）
        ```js
        identity = i => { return i } 
        // 调用函数 identity(1) 可以直接被 1 替换掉，这个过程被称为替换模型

        ```

## 专业术语

- 纯函数

    - 函数不依赖外部环境的状态
    - 相同的输入总是相同的输出
       ```js
       // 这个函数依赖了外部的 num， 所以不是存函数 
        var num = 5;
        function a (b){
            return b> num
        }
        // 变量只能传入进去
        function b(a, b){
            return a>bß
        }
       ```

- 幂等性

执行过无数次后，还具有相同的效果

同一参数，执行1次与执行 2次的结果一致

- 偏应用函数（partial application）

    传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

    ```js
    // 带一个 ‘函数参数’ 和 ‘该函数的部分参数’
    const partial = (f, ...args) => (...moreArgs) => f(...args, ...moreargs)
    const add3 = (a, b, c) => a + b + c
    const fiveplus = partial(add3, 2, 3)
    fiveplus(3)

    // bind 实现方法
    const addMore = add3.bind(null, 3, 2)

    ```
    - 柯里化
        - 柯里化通过偏应用函数来实现。他是把一个多参数函数转换为一个嵌套一元函数的过程
        - 柯里化是一种“预加载”函数的方法，这是一种对函数的缓存，是一种高效的编程方法
            (通过传递较少的参数，得到一个已经记住这个参数的函数，这就是一种对参数的缓存)

        ```js
        // 改造硬编码函数
        var checkage = age => age > 18
        // 改造后
        var checkage = min => (age => age > min)
        var checkage18 = checkage(18)
        checkage18(30)

        // 另一个柯里化的例子
        function add(a, b){
            return a + b
        }
        add(1, 2)

        // 柯里化
        function addX (a){
            return function(b){
                return a + b
            }
        }
        add(2)(3)
        ```

    - 柯里化和偏应用函数的区别
        - 柯里化函数的参数是从左向右的
        - 偏应用函数不关心参数的位置，偏应用函数中使用了占位符

            柯里化的参数列表是从左向右的，如果使用 setTimeout 这种就得额外的封装
        
        ```js
        const setTimeoutWrapper = (time, fn)=> setTimeout(fn, time)
        const delay10 = curry(setTimeoutWrapper)(10)
        delay10(()=> console.log("task one"))
        delay10(()=> console.log("task two"))

        ```
    - setTimeoutWrapper 显得多余，这时我们就可以使用偏函数。
    使用 curry 和 partial 是为了让函数参数或函数设置变得更加简单和强大。
    curry、partial 实现可以参考 lodash

    - 函数的反柯里化
        - 函数柯里化是固定部分参数， 返回一个接收剩余参数的函数（也称为部分计算函数）
        目的是为了缩小适用范围，创建一个适用性更强的函数
        - 反柯里化，和柯里化相反，扩大适用范围，创建一个应用范围更广的函数。
        使本来只有特定对象才适用的方法，扩展到更多的对象
    ```js
    Function.prototype.uncurring = function uncurring(){
        var self = this;
        return function(){
            var obj = Array.prototype.shift.call(arguments)
            return self.apply(obj, arguments)
        }
    }
    var push = Array.prototype.push.uncurring()
    var obj = {}
    push(obj, 'first', 'second')
    console.log(obj)

    ```
    
- 函数组合

    纯函数 和 把它柯里化写出的洋葱代码  `h(g(f()))` 成了这个样子
    
    为了解决函数嵌套问题，出现了组合函数

    - 解决了函数嵌套不好理解的问题，让函数看起来更好理解

    ```js
    const compose = (f, g) => (x => f(g(x)))
    var first = arr => arr[0]
    var reverse = arr => arr.reverse()
    var last = compose(first, reverse)
    last([1,2,3,4,5])

    // 因为都是纯函数，所以我们可以任意调整函数的组合方式
    // 他们最后的结果都是等效的
    compose(f, compose(g, h))
    compose(compose(f, g), h)
    compose(f, g, h)

    ```

- 投影函数 （如 map ，给他们起的另一个名字）

    总是在应用转换操作，通过传入高阶参数后返回数组

- 函数的组合子（组合子就是管理程序的控制流）
    
    - compose 函数只能组合一个参数的函数，像 map 、filter 这样可以接收多个参数的函数
    不能使用 compose 直接组合，需要借助偏函数包裹后继续组合
    - 函数组合的数据流是从右至左，因为右边的函数先执行，如 `f(g(h))` 过程是 `h -> g -> f`；
    有人喜欢另一种执行方式，从左至右 执行（我们叫他管道，pipe、序列），他和 compose 做的事情
    一样，只不过是数据流动的方向被改变了
    - 命令式代码能够使用 if-else 和 for 这样的过程控制，函数式不能。
    所以我们需要函数组合子。组合子可以组合其他函数（或其他组合子），作为控制逻辑单元的高阶函数（high order function）。组合子通常不声明任何变量，也不包含任何业务逻辑，他们旨在管理函数程序执行流程，
    并在链式调用中对中间结果进行操作。

    常见的组合子

    ```js
    // 辅助组合子
    无为 nothing 、照旧 identity 、默许 defaultTo 、恒定 always

    // 函数组合子
    收缩 gather 、展开 spread 、颠倒 reverse 、左偏 partial 、右偏 partialRight
    柯里化 curry 、弃离 tap 、交替 alt 、补救 trycatch 、同时 seq 、聚集 converge、
    映射 map 、分拣 useWith 、规约 reduce 、组合 compose

    // 谓语组合子
    过滤 filter 、 分组 group 、排序 sort

    // 其他
    组合子变换 juxt

    ```
    分属于ski（来源于数学）组合子， 用于数据的剥离

- point Free （实现函数编程的目的 抽象组合， point free 负责抽象）

    - 把对象自带的方法转为纯函数，免去声明那些不需要的变量
    - point free 处理那些能够用于组合的 原生方法，通过和其他函数组合成为高阶函数。
    让代码更灵活、更强壮
    ```js
    // 下面这个函数，使用str 作为中间变量，但是这个中间变量除了让代码变长了一点之外是毫无意义的
    const f = str => str.toUpperCase().split(' ')
    // point free
    var toUpperCase = word => word.toUpperCase()
    var split = x => str => str.split(x)

    var f = compose(split(' '), toUpperCase)
    f('abc df')
    ```
    
- 命令式代码 和 声明式代码
   - 命令式代码就是通过编写一条条指令去让计算机执行一些动作，这其中涉及很多繁杂的细节。
   - 声明式代码通过 写表达式 的方式来声明我们想干什么
   - 函数式编程不关注流程，只关注进去后出来什么
   - 以函数形式对数据建模，也就是函数即数据。声明式的描述了数据输出是什么，而不是数据是如何得到的

   - 函数式编程明显的好处就是声明式的代码，对于无副作用的纯函数来说，我们不需要关心它的内部实现，
   专注于编写业务代码。优化代码时目光只需要集中在这些坚固稳定的函数内部即可；
   - 相反，不纯的代码的副作用或者依赖外部环境，使用他们的时候总是需要考虑不干净的副作用。
   在复杂的系统中，这对于程序员来说是极大的负担

- 惰性链、惰性求值、惰性函数

    - `_.chain(数据).map().reverse().value()` 惰性链可以添加一个输入对象的状态，从而能够将这些
    ×输入转换为所需的输出操作×连接在一起。 与简单的数组操作不同，尽管他是一个复杂的程序，但是仍然能
    避免创建任何变量，并且有效消除所有循环。而且在最后调用 value 之前并不会真正执行任何操作。
    这就是 ××惰性链××
 
    - 当输入很大，但是只有一个小的子集有效时，避免不必要的函数调用，就是所谓的 ×× 惰性求值××

        - 惰性求值的方法有很多，如×组合子×（alt 类似于 || 先计算fun1 如果返回值是false、null
        undefined 就不再执行 fun2；memorization； shortcut funsion） 但是目的都是一样的
        即尽可能的推迟求值，直到依赖的表达式被调用。
    - 惰性函数，假如同一个函数被大量调用，并且这个函数内部又有许多判断来检测函数，这样对于一个调用
    会浪费时间和浏览器资源，所以当第一次判断完成后，直接把这个函数改写，不再需要判断。

    ```js
    // 惰性求值的例子
    // alt
    const alt = _.curry( (fun1, fun2, val) => fun1(val) || fun2(val) )
    const showStudent = _.compose(函数体1, alt(xx1, xx2))
    showStudent({})

    // memorize
    // object 被装载后，如果没有再次进行装载，下次缓存里拿到的值还是原来的值，
    // 中途values 的改变不会被拿到
    var object = {a: 1, b:'ww'}
    var values = _.memorize(_.values)
    values(object)
    object.a = 'yideng'
    console.log(values.cache.get(object))

    // _.chain 可以推断可优化点，如合并执行或存储优化
    // 合并函数执行，并压缩计算过程中使用的临时数据结构，降低内存占用
    const trace = msg => console.log(msg)
    let square = x => x**2
    let isEven = x => x%2 === 0
    square = R.compose(R.tap( ()=> trace("map数组") ), square )
    isEven = R.compose( T.tap(()=> trace("filter数组")), isEven)
    const numbers = _.range(200);
    const result = _.chain(numbers)
        .map(squire)
        .filter(isEven)
        .take(3)
        .value()

    console.log(result)
    // 首先，take(3) 只担心前3个通过map和filter 的值
    // 其实 shortcut fusion 技术把map 和 filter融合
    // _.compose(filter(isEven), map(square))
    // compose(filter(p1), filter(p2)) =>filter(x => p1(x) && p2(x))
    // lodash 中其他带有 shortcutfusion 优化函数 _.drop ..
    // _.drop  _.dropRight  _.dropRightWhile  _.dropWhile


    // jquery 中经典的惰性求值函数
    function createXHR(){
        var xhr = null;
        if( typeof XMLHttpRequest != 'undefined'){
            xhr = new XMLHttpRequest()
            // 重写 createXHR
            createXHR = function(){
                return XMLHttpRequest()
            }
        }else {
            try {
                xhr = new ActiveXObject("Msxml2.XMLHTTP")
                createXHR = function (){
                    return new ActiveXObject("Msxml2.XMLHTTP")
                }
            }catch (e){
                try {
                    xhr = new ActiveXObject("Microsoft.XMLHTTP")
                    createXHR = function (){
                        return new ActiveXObject("Microsoft.XMLHTTP")
                    }
                }catch (e) {
                    createXHR = function (){
                        return null
                    }
                }
            }
        }
    }
    ```

