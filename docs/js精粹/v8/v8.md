# v8

### v8 引擎


### linux 用户空间 与 内核空间

- 为什么要区分内核空间与用户空间

    因为他们的执行权限不一致，权限分为 4层，操作系统在第 0 层，
    程序运行在第 3 层，1,2层目前没有用到
    CPU的运行状态：
        - 用户
        - 内核
        - 切换中

- 内核态与用户态
- 如何从用户空间进入内核空间
- 处理器在任何指定时间点上的活动概括为下列三者之一：
    - 运行于用户空间，执行用户进程
    - 运行于内核空间，处于进程上下文，代表某个特定的进程执行
    - 运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断

### Linux 信号机制

- 软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。进程之间可以相互通过系统调用 Kill 发送软中断信号。
内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据
- 对信号的处理办法
    1. 对于需要处理的信号，进程可以指定处理函数，由该函数来处理。
    2. 忽略某个信号，对该信号不做任何处理，就像未发生过一样。其中，有2个信号不能忽略：SIGKILL 及 SIGSTOP
    3. 对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用 signal 来指定进程对某个信号的处理行为。

- 内核处理一个进程收到的信号的时机，是在一个进程从内核态返回用户态时

### Linux 的 I/O 模型

- 同步和异步 （上层机制 -- nodejs）
- 阻塞和非阻塞 （底层机制 -- 操作系统api）
- 每个 I/O 模型都有它合适的应用场景

#### 同步阻塞 I/O 模型

- 这种是最常见的模型
- 用户空间的应用程序在执行系统调用之后会被阻塞，直到系统调用完成（数据传输完成或出现错误）。此时应用程序只是处于简单的等待响应状态，不会消耗 CPU
- 站在CPU的角度他是高效的

#### 同步非阻塞 I/O 模型

- 同步阻塞 I/O 模型的一种变体，是效率较低的同步非阻塞 I/O 模型
- 非阻塞意味着，如果I/O 操作不能立即完成，则需要应用程序多次调用知道任务完成
- 这可能非常低效，因为大多数时候应用程序必须忙等待或者尝试做其它事情直到数据可用。

#### 异步阻塞 I/O 模型

- 设备以非阻塞方式打开，然后应用程序阻塞在select系统调用中，用它来监听可用的I/O操作
- select系统调用最大的好处是可以监听多个描述符，而且可以指定每个描述符要监听的事件：可读事件、可写事件和发生错误事件
- select的主要问题是效率不高。虽然它是一个非常方便的异步通知模型，但不建议将其用于高性能I/O 中
- 高性能场景一般使用 epoll 系统调用

#### 异步非阻塞 I/O 模型

- 是可以并行处理 I/O 的模型
- 它的读取请求会立即返回，表明读操作成功启动。
- 

#### 事件循环



#### select


#### epoll

- epoll 模型店有点：
    - 支持一个进程打开大数目的 socket 描述符
    - IO 效率不随FD数目增加而线性下降
    - 使用 mmap 加速内核与用户空间的消息传递

- epoll 的2种工作模式：
    - LT（level trigger, 水平触发）
    - ET（edge-triggered, 边缘触发模式）

#### IOCP 模型（windows）

- 创建一个完成端口
- 

### libuv

- libuv 是用 c 写的，因此，它具有很高的可移植性，非常适用嵌入到像 js 和Python这样的高级语言中。
- libuv 使用异步，事件驱动的编程方式，核心是提供IO的事件循环和异步回调
- libuv 的API包含有时间，非阻塞的网络，异步文件操作，子进程等等
- 当程序在等待 IO 完成的时候，我们希望

- 源码 loop/loopwatcher/core

###　v8 源码分析

#### 渲染引擎及 webkit 体系结构

- 渲染引擎：能够将 HTML、css、js 文本及相应资源文件转换成图像结果

- 渲染引擎的种类
    - Tridend (IE)
    - Gecko (FF)
    - webkit (safari,chrome,android)

```
-------------------------------------------------------------------------
| webkit 嵌入式接口        |        webkit2 嵌入式接口                      |
|------------------------------------------------------------------------
|  webkit 绑定            |       webkit2 绑定                            |
--------------------------------------------------------------------------
|    webCore              |  JS  |           webkit Ports                |
| css | svg | 布局 | 渲染树 | CORE | 网络栈 | 视频 | 文字 |                  |
| HTML | dom | inspector..|      |  硬件加速 | 图片解码 ...                 |
-------------------------------------------------------------------------|
  2D图形库 | 3D图形库 | 网络库 | 存储 | 音频库 | 视频库 ...                    
--------------------------------------------------------------------------
|                               操作系统                                   |
--------------------------------------------------------------------------
```

#### js 引擎与 渲染引擎

- 渲染引擎使用 js 引擎的接口来处理逻辑代码，并获取结果
- js 引擎通过桥接 API 访问渲染引擎中 dom 和 cssom

```
渲染引擎  --------> 调用接口 ------------> js 引擎
    ⇑                                   ⇊
桥接API的实现（dom，HTML等）<----------- 桥接接口


# js 引擎工作流程

源代码 --------> 抽象语法树 -------> 字节码
                              ⇙
                          ⇙ 
                    解析器  ---------> JIT
                       ⇈               ⇊
                       ⇈               ⇊
            垃圾回收，分析工具 -------> 本地代码

# jit 可以 直接将 抽象语法树解析成机器码

```

#### v8 与 jsCore 区别

- js core 引擎是 webkit 中默认的 js 引擎，也是苹果开源的一个项目，应用较为广泛。最初，
性能不是很好，从 2008 年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能
有较大的提升。随后内嵌缓存、基于正则表达式的 jit、简单的 jit 及字节码解释器等技术引入进来，
js 引擎也在不断的迭代和发展

- js core 与 v8 有一些不同之处，其中最大的不同就是增加了字节码的中间表示，并加入了多层 jit
编译器（如：简单jit 编译器、DFG jit编译器、LLVM 等）优化性能，不停地对本地代码进行优化。

#### v8 源码

- [文档](https://v8.dev/docs)
- [源码](https://cs.chromium.org/chromium/src/v8)
- 通过源代码可以学到的东西
    - 增强对 js 的理解
    - 前端算法
    - 内存管理与 GC 算法
    - 编译原理、操作系统知识
    - 面试解锁 高级方式

···c++
// v8 项目结构

// include 为v8引擎做功能导出
    // v8.h  所有头文件的汇总
        #include <stdio.h>  // c 语言标准库 
        #include <string>  // c++ 语言标准库 
        #include "include/v8.h"  // 引入自己的模块
        namespace v8{}      // 命名空间（声明的作用域）  
// src 代码逻辑
    // heap 堆代码的实现
        // heep.h
···