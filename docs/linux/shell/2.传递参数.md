# shell 传递参数

当我们在执行命令的时候，总是想在命令后添加自己要的参数，然后根据参数做不同的操作，这也为我们的开发变得更顺畅

参数 | 说明
--|--|--
$0 |  运行的命令
$1 |  第一个传递的参数
$# |  传递参数个数
$$ |  脚本运行的当前进程的 id
$! |  后台运行的最后一个进程的ID号         Mac 不支持
$* |  以一个单字符串显示所有向脚本传递的参数
$@ |  与$*相同，但是使用时加引号，并在引号中返回每个参数。
$- |  显示Shell使用的当前选项，与set命令功能相同
$? |  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

```sh
# test.sh
echo $0
echo $1
echo $2
echo $3
echo $#  # 传递参数个数
echo $$  # 脚本运行的当前进程的 id
echo $!  # 后台运行的最后一个进程的ID号         Mac 不支持
echo $*  # 以一个单字符串显示所有向脚本传递的参数
echo $@  # 与$*相同，但是使用时加引号，并在引号中返回每个参数。
echo $-  # 显示Shell使用的当前选项，与set命令功能相同
echo $?  # 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

# 输出结果如下
# ./bash/dev.sh  第0个参数   
# 1
# 2
# 3
# 3            传递的参数个数
# 65789              

# 1 2 3
# 1 2 3
# hB
# 0


```
$* 与 $@ 的区别：

- 相同点：都是引用所有参数
- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

```sh

echo "-- \$* 演示 ---"
for i in "$*"; do
    echo $i
done

echo "-- \$@ 演示 ---"
for i in "$@"; do
    echo $i
done

# -- $* 演示 ---
# 1 2 3
# -- $@ 演示 ---
# 1
# 2
# 3
#

# 当参数中含有空格的时候要用引号将参数包裹起来
# ./bash/dev.sh '1 2 3'

```

### shell [中的中括号用法总结](https://www.runoob.com/w3cnote/shell-summary-brackets.html)

操作符 | 说明
--|--|--
-gt	| 大于
-lt	| 小于
-ge	| 大于或等于
-le	| 小于或等于
-eq | 等于
-ne | 返回 布尔值
[ -f $file_var ]	| 变量 $file_var 是一个正常的文件路径或文件名 (file)，则返回真
[ -x $var ]	| 变量 $var 包含的文件可执行 (execute)，则返回真
[ -d $var ]	| 变量 $var 包含的文件是目录 (directory)，则返回真
[ -e $var ]	| 变量 $var 包含的文件存在 (exist)，则返回真
[ -c $var ]	| 变量 $var 包含的文件是一个字符设备文件的路径 (character)，则返回真
[ -b $var ]	| 变量 $var 包含的文件是一个块设备文件的路径 (block)，则返回真
[ -w $var ]	| 变量 $var 包含的文件可写(write)，则返回真
[ -r $var ]	| 变量 $var 包含的文件可读 (read)，则返回真
[ -L $var ]	| 变量 $var 包含是一个符号链接 (link)，则返回真

- 算术比较, 比如一个变量是否为0, [ $var -eq 0 ]。
- 文件属性测试，比如一个文件是否存在，[ -e $var ], 是否是目录，[ -d $var ]。
- 字符串比较, 比如两个字符串是否相同， [[ $var1 = $var2 ]]。


```sh

ss=0
a=1
c=aa
d=bb
e=aa
echo --$ss == 0---
if `[ $ss -eq 0 ]` ; then
echo 111
fi
echo --$a == 0---
if `[ $a -eq 0 ]` ; then
echo 222
fi
echo --$c == $e---
if [[ $c = $e ]] ; then
echo c=e
fi
echo --$c == $d---
if [[ $c = $d ]] ; then
echo c=d
fi

# 结果如下

# --0 == 0---
# 111
# --1 == 0---
# --aa == aa---
# c=e
# --aa == bb---

```