# 图形学入门

- 可视化 在线文档  nobook.com

- 数据显示过程

    数据指令（只有0和1）--> CPU --> 显卡驱动 --> 显卡 --> 显示器 --> 人眼

    - 液晶显示器原理

        白光 --> 不同强度的滤光片（通过电压来控制液晶排布） --> 黄绿蓝比例不一样，混合出不通的颜色

    - 显卡

        CPU数据 传送到 GPU --> 处理完成的数据放入显存 --> 把显存中的数字信号转为模拟信号

### CPU和GPU

- CPU

    - 计算
    - 寄存器存储
    - 控制

- GPU

    - 大量计算
    - 少量存储控制


### canvas2d 和 webgl

- canvas 2d

    图形 -> cpu 计算出数据 -> 显卡 -> gpu (为了显示而计算，光栅化) -> 旋转等动画 -> cpu 重新计算 -> 显卡 -> gpu 

- webgl

    图形 -> gpu (用户告诉GPU怎么去进行计算,变形过程在GPU内计算) -> 显卡 -> gpu 


- [openGL](https://learnopengl-cn.github.io/)

#### 光栅化

- 应用意义：光栅化其实是一种将几何图元变为二维图像的过程。该过程包含2部分工作。第一部分：决定窗口坐标中的哪些整形栅格区域被基本图元占用；
第二部分：分配一个颜色值和一个深度值到各个区域。光栅化过程产生的是片元

- 数学意义：这是一个将模拟信号转化为离散信号打过程

- 片元：二维图像每个点都包含了颜色、深度、纹理数据。这些集合汇总就是片元

- 容易理解的解释：显示器是2D的，他比较蠢，只能显示特定格式打2D像素。一个复杂打模型由许多顶点还有三角形构成，这些顶点经过 **矩阵** 变化后得到的还是顶点，
而由这些顶点构成打三角形还要在 2D 屏幕上显示出来，还需要片元信息。从程序角度来讲，就是把 A 格式转化成 B 格式，显示器才认识，光栅化 = 数据格式化

#### canvas

基础文档 [mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API) , [canvas-cn](https://www.canvasapi.cn/)

1. 图形拾取

    - isPointInPath 需要在点击时重复构造路径，需要重复迭代
    - 数学计算，只适用规则图形
    - 颜色拾取，逻辑物体对应唯一的颜色 --> 找到物体 --> 执行动作

2. 局部渲染
3. 图形层叠控制
4. 事件机制的封装


### 可视化地图的实现

地球 --> 莫卡托投影 成平面

- 性能优化

    - webworker  postMessage(结构化克隆算法)
    - sharedArrayBuffer  Atomics
    - webAssembly  

- 开源项目

    - xspreadsheet

### 3d 图形

- 正交投影
- 透视投影

## webGL

着色器语言  --> 数据计算 坐标变化

3d 图形是由多个平面组成的，任何平面都是由图元（点、线、三角形）组成的

3d 处理过程： 定点 -> 图元 -> 片元

## 相关库

- 数据可视化

    ECharts 、Highcharts 、D3.js

- 跨界 AR/VR 

    React AR/VR、ar.js 、

### threejs

- light 光源


### 其他工具

- obj2gltf
- gltf-pipeline   模型压缩工具