/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkyd_react_generator"] = self["webpackChunkyd_react_generator"] || []).push([["vendors-node_modules_react-query_dist_react-query_mjs"],{

/***/ "./node_modules/react-query/dist/react-query.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-query/dist/react-query.mjs ***!
  \*******************************************************/
/*! namespace exports */
/*! export CancelledError [provided] [no usage info] [missing usage info prevents renaming] */
/*! export QueryStatus [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ReactQueryCacheProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ReactQueryConfigProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isCancelledError [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isError [provided] [no usage info] [missing usage info prevents renaming] */
/*! export makeQueryCache [provided] [no usage info] [missing usage info prevents renaming] */
/*! export queryCache [provided] [no usage info] [missing usage info prevents renaming] */
/*! export queryCaches [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setConsole [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setFocusHandler [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setOnlineHandler [provided] [no usage info] [missing usage info prevents renaming] */
/*! export useInfiniteQuery [provided] [no usage info] [missing usage info prevents renaming] */
/*! export useIsFetching [provided] [no usage info] [missing usage info prevents renaming] */
/*! export useMutation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export usePaginatedQuery [provided] [no usage info] [missing usage info prevents renaming] */
/*! export useQuery [provided] [no usage info] [missing usage info prevents renaming] */
/*! export useQueryCache [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CancelledError\": () => /* binding */ CancelledError,\n/* harmony export */   \"QueryStatus\": () => /* binding */ QueryStatus,\n/* harmony export */   \"ReactQueryCacheProvider\": () => /* binding */ ReactQueryCacheProvider,\n/* harmony export */   \"ReactQueryConfigProvider\": () => /* binding */ ReactQueryConfigProvider,\n/* harmony export */   \"isCancelledError\": () => /* binding */ isCancelledError,\n/* harmony export */   \"isError\": () => /* binding */ isError,\n/* harmony export */   \"makeQueryCache\": () => /* binding */ makeQueryCache,\n/* harmony export */   \"queryCache\": () => /* binding */ defaultQueryCache,\n/* harmony export */   \"queryCaches\": () => /* binding */ queryCaches,\n/* harmony export */   \"setConsole\": () => /* binding */ setConsole,\n/* harmony export */   \"setFocusHandler\": () => /* binding */ setFocusHandler,\n/* harmony export */   \"setOnlineHandler\": () => /* binding */ setOnlineHandler,\n/* harmony export */   \"useInfiniteQuery\": () => /* binding */ useInfiniteQuery,\n/* harmony export */   \"useIsFetching\": () => /* binding */ useIsFetching,\n/* harmony export */   \"useMutation\": () => /* binding */ useMutation,\n/* harmony export */   \"usePaginatedQuery\": () => /* binding */ usePaginatedQuery,\n/* harmony export */   \"useQuery\": () => /* binding */ useQuery,\n/* harmony export */   \"useQueryCache\": () => /* binding */ useQueryCache\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar QueryStatus;\n\n(function (QueryStatus) {\n  QueryStatus[\"Idle\"] = \"idle\";\n  QueryStatus[\"Loading\"] = \"loading\";\n  QueryStatus[\"Error\"] = \"error\";\n  QueryStatus[\"Success\"] = \"success\";\n})(QueryStatus || (QueryStatus = {}));\n\nvar CancelledError = function CancelledError() {}; // UTILS\n\nvar _uid = 0;\nvar uid = function uid() {\n  return _uid++;\n};\nvar isServer = typeof window === 'undefined';\n\nfunction noop() {\n  return void 0;\n}\n\nvar Console = console || {\n  error: noop,\n  warn: noop,\n  log: noop\n};\nfunction setConsole(c) {\n  Console = c;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\n\nfunction stableStringifyReplacer(_key, value) {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value');\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value).sort().reduce(function (result, key) {\n      result[key] = value[key];\n      return result;\n    }, {});\n  }\n\n  return value;\n}\n\nfunction stableStringify(value) {\n  return JSON.stringify(value, stableStringifyReplacer);\n}\nfunction deepIncludes(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !deepIncludes(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\nfunction isDocumentVisible() {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true;\n  }\n\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n}\nfunction isOnline() {\n  return navigator.onLine === undefined || navigator.onLine;\n}\nfunction getQueryArgs(args) {\n  var queryKey;\n  var queryFn;\n  var config;\n  var options;\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey;\n    queryFn = args[0].queryFn;\n    config = args[0].config;\n    options = args[1];\n  } else if (isObject(args[1])) {\n    queryKey = args[0];\n    config = args[1];\n    options = args[2];\n  } else {\n    queryKey = args[0];\n    queryFn = args[1];\n    config = args[2];\n    options = args[3];\n  }\n\n  config = config ? _extends({\n    queryKey: queryKey\n  }, config) : {\n    queryKey: queryKey\n  };\n\n  if (queryFn) {\n    config = _extends({}, config, {\n      queryFn: queryFn\n    });\n  }\n\n  return [queryKey, config, options];\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  var array = Array.isArray(a) && Array.isArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    var aSize = array ? a.length : Object.keys(a).length;\n    var bItems = array ? b : Object.keys(b);\n    var bSize = bItems.length;\n    var copy = array ? [] : {};\n    var equalItems = 0;\n\n    for (var i = 0; i < bSize; i++) {\n      var key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\nfunction isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a);\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  var ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  var prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction sleep(timeout) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction getStatusProps(status) {\n  return {\n    status: status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle\n  };\n}\nfunction createSetHandler(fn) {\n  var removePreviousHandler;\n  return function (callback) {\n    // Unsub the old handler\n    if (removePreviousHandler) {\n      removePreviousHandler();\n    } // Sub the new handler\n\n\n    removePreviousHandler = callback(fn);\n  };\n}\n\n// CONFIG\nvar defaultQueryKeySerializerFn = function defaultQueryKeySerializerFn(queryKey) {\n  try {\n    var arrayQueryKey = Array.isArray(queryKey) ? queryKey : [queryKey];\n    var queryHash = stableStringify(arrayQueryKey);\n    arrayQueryKey = JSON.parse(queryHash);\n    return [queryHash, arrayQueryKey];\n  } catch (_unused) {\n    throw new Error('A valid query key is required!');\n  }\n};\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\n\nvar DEFAULT_CONFIG = {\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    enabled: true,\n    retry: 3,\n    retryDelay: function retryDelay(attemptIndex) {\n      return Math.min(1000 * Math.pow(2, attemptIndex), 30000);\n    },\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchOnReconnect: true,\n    refetchOnMount: true,\n    structuralSharing: true\n  }\n};\nfunction mergeReactQueryConfigs(a, b) {\n  return {\n    shared: _extends({}, a.shared, b.shared),\n    queries: _extends({}, a.queries, b.queries),\n    mutations: _extends({}, a.mutations, b.mutations)\n  };\n}\nfunction getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, configOverrides) {\n  return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.queries, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.queries, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.queries, config, configOverrides);\n}\nfunction getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, configOverrides) {\n  return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.mutations, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.mutations, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.mutations, config, configOverrides);\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar QueryObserver = /*#__PURE__*/function () {\n  function QueryObserver(config) {\n    this.config = config; // Bind exposed methods\n\n    this.clear = this.clear.bind(this);\n    this.refetch = this.refetch.bind(this);\n    this.fetchMore = this.fetchMore.bind(this); // Subscribe to the query\n\n    this.updateQuery();\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.subscribe = function subscribe(listener) {\n    this.started = true;\n    this.updateListener = listener;\n    this.currentQuery.subscribeObserver(this);\n    this.optionalFetch();\n    this.updateRefetchInterval();\n    return this.unsubscribe.bind(this);\n  };\n\n  _proto.unsubscribe = function unsubscribe() {\n    this.started = false;\n    this.updateListener = undefined;\n    this.clearRefetchInterval();\n    this.currentQuery.unsubscribeObserver(this);\n  };\n\n  _proto.updateConfig = function updateConfig(config) {\n    var prevConfig = this.config;\n    this.config = config;\n    var updated = this.updateQuery(); // Take no further actions if the observer did not start yet\n\n    if (!this.started) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (updated) {\n      this.optionalFetch();\n      this.updateRefetchInterval();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch();\n    } // Update refetch interval if needed\n\n\n    if (config.enabled !== prevConfig.enabled || config.refetchInterval !== prevConfig.refetchInterval || config.refetchIntervalInBackground !== prevConfig.refetchIntervalInBackground) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.clear = function clear() {\n    return this.currentQuery.clear();\n  };\n\n  _proto.refetch = function refetch(options) {\n    try {\n      var _this2 = this;\n\n      _this2.currentQuery.updateConfig(_this2.config);\n\n      return _this2.currentQuery.refetch(options);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {\n    try {\n      var _this4 = this;\n\n      _this4.currentQuery.updateConfig(_this4.config);\n\n      return _this4.currentQuery.fetchMore(fetchMoreVariable, options);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetch = function fetch() {\n    try {\n      var _this6 = this;\n\n      _this6.currentQuery.updateConfig(_this6.config);\n\n      return _catch(function () {\n        return _await(_this6.currentQuery.fetch());\n      }, function () {\n        return undefined;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.config.enabled && // Don't auto refetch if disabled\n    !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n    this.currentResult.isStale && ( // Only refetch if stale\n    this.config.refetchOnMount || this.currentQuery.observers.length === 1)) {\n      this.fetch();\n    }\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this7 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearRefetchInterval();\n\n    if (!this.config.enabled || !this.config.refetchInterval || this.config.refetchInterval < 0 || this.config.refetchInterval === Infinity) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this7.config.refetchIntervalInBackground || isDocumentVisible()) {\n        _this7.fetch();\n      }\n    }, this.config.refetchInterval);\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  };\n\n  _proto.createResult = function createResult() {\n    var currentQuery = this.currentQuery,\n        previousResult = this.previousResult,\n        config = this.config;\n    var _currentQuery$state = currentQuery.state,\n        canFetchMore = _currentQuery$state.canFetchMore,\n        error = _currentQuery$state.error,\n        failureCount = _currentQuery$state.failureCount,\n        isFetched = _currentQuery$state.isFetched,\n        isFetching = _currentQuery$state.isFetching,\n        isFetchingMore = _currentQuery$state.isFetchingMore,\n        isLoading = _currentQuery$state.isLoading,\n        isStale = _currentQuery$state.isStale;\n    var _currentQuery$state2 = currentQuery.state,\n        data = _currentQuery$state2.data,\n        status = _currentQuery$state2.status,\n        updatedAt = _currentQuery$state2.updatedAt; // Keep previous data if needed\n\n    if (config.keepPreviousData && isLoading && (previousResult == null ? void 0 : previousResult.isSuccess)) {\n      data = previousResult.data;\n      updatedAt = previousResult.updatedAt;\n      status = previousResult.status;\n    }\n\n    return _extends({}, getStatusProps(status), {\n      canFetchMore: canFetchMore,\n      clear: this.clear,\n      data: data,\n      error: error,\n      failureCount: failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: isFetched,\n      isFetching: isFetching,\n      isFetchingMore: isFetchingMore,\n      isStale: isStale,\n      query: currentQuery,\n      refetch: this.refetch,\n      updatedAt: updatedAt\n    });\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var prevQuery = this.currentQuery; // Remove the initial data when there is an existing query\n    // because this data should not be used for a new query\n\n    var config = prevQuery ? _extends({}, this.config, {\n      initialData: undefined\n    }) : this.config;\n    var newQuery = config.queryCache.buildQuery(config.queryKey, config);\n\n    if (newQuery === prevQuery) {\n      return false;\n    }\n\n    newQuery.activateTimeouts();\n    this.previousResult = this.currentResult;\n    this.currentQuery = newQuery;\n    this.currentResult = this.createResult();\n\n    if (this.started) {\n      prevQuery == null ? void 0 : prevQuery.unsubscribeObserver(this);\n      this.currentQuery.subscribeObserver(this);\n    }\n\n    return true;\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(_state, action) {\n    var _this$updateListener;\n\n    this.currentResult = this.createResult();\n    var _this$currentResult = this.currentResult,\n        data = _this$currentResult.data,\n        error = _this$currentResult.error,\n        isSuccess = _this$currentResult.isSuccess,\n        isError = _this$currentResult.isError;\n\n    if (action.type === 'Success' && isSuccess) {\n      var _this$config$onSucces, _this$config, _this$config$onSettle, _this$config2;\n\n      (_this$config$onSucces = (_this$config = this.config).onSuccess) == null ? void 0 : _this$config$onSucces.call(_this$config, data);\n      (_this$config$onSettle = (_this$config2 = this.config).onSettled) == null ? void 0 : _this$config$onSettle.call(_this$config2, data, null);\n      this.updateRefetchInterval();\n    } else if (action.type === 'Error' && isError) {\n      var _this$config$onError, _this$config3, _this$config$onSettle2, _this$config4;\n\n      (_this$config$onError = (_this$config3 = this.config).onError) == null ? void 0 : _this$config$onError.call(_this$config3, error);\n      (_this$config$onSettle2 = (_this$config4 = this.config).onSettled) == null ? void 0 : _this$config$onSettle2.call(_this$config4, undefined, error);\n      this.updateRefetchInterval();\n    }\n\n    (_this$updateListener = this.updateListener) == null ? void 0 : _this$updateListener.call(this, this.currentResult);\n  };\n\n  return QueryObserver;\n}();\n\nfunction _await$1(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch$1(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _empty() {}\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nvar ActionType;\n\n(function (ActionType) {\n  ActionType[\"Failed\"] = \"Failed\";\n  ActionType[\"MarkStale\"] = \"MarkStale\";\n  ActionType[\"Fetch\"] = \"Fetch\";\n  ActionType[\"Success\"] = \"Success\";\n  ActionType[\"Error\"] = \"Error\";\n})(ActionType || (ActionType = {}));\n\n// CLASS\nvar Query = /*#__PURE__*/function () {\n  function Query(init) {\n    this.config = init.config;\n    this.queryCache = init.queryCache;\n    this.queryKey = init.queryKey;\n    this.queryHash = init.queryHash;\n    this.notifyGlobalListeners = init.notifyGlobalListeners;\n    this.observers = [];\n    this.state = getDefaultState(init.config);\n    this.enableTimeouts = false;\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.activateTimeouts = function activateTimeouts() {\n    this.enableTimeouts = true;\n    this.rescheduleStaleTimeout();\n    this.rescheduleGarbageCollection();\n  };\n\n  _proto.updateConfig = function updateConfig(config) {\n    this.config = config;\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this = this;\n\n    this.state = queryReducer(this.state, action);\n    this.observers.forEach(function (d) {\n      return d.onQueryUpdate(_this.state, action);\n    });\n    this.notifyGlobalListeners(this);\n  };\n\n  _proto.rescheduleStaleTimeout = function rescheduleStaleTimeout() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearStaleTimeout();\n\n    if (!this.enableTimeouts || this.state.isStale || this.state.status !== QueryStatus.Success || this.config.staleTime === Infinity) {\n      return;\n    }\n\n    var staleTime = this.config.staleTime || 0;\n    var timeout = staleTime;\n\n    if (this.state.updatedAt) {\n      var timeElapsed = Date.now() - this.state.updatedAt;\n      var timeUntilStale = staleTime - timeElapsed;\n      timeout = Math.max(timeUntilStale, 0);\n    }\n\n    this.staleTimeout = setTimeout(function () {\n      _this2.invalidate();\n    }, timeout);\n  };\n\n  _proto.invalidate = function invalidate() {\n    this.clearStaleTimeout();\n\n    if (this.state.isStale) {\n      return;\n    }\n\n    this.dispatch({\n      type: ActionType.MarkStale\n    });\n  };\n\n  _proto.rescheduleGarbageCollection = function rescheduleGarbageCollection() {\n    var _this3 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearCacheTimeout();\n\n    if (!this.enableTimeouts || this.config.cacheTime === Infinity || this.observers.length > 0) {\n      return;\n    }\n\n    this.cacheTimeout = setTimeout(function () {\n      _this3.clear();\n    }, this.config.cacheTime);\n  };\n\n  _proto.refetch = function refetch(options) {\n    try {\n      var _this5 = this;\n\n      return _catch$1(function () {\n        return _await$1(_this5.fetch());\n      }, function (error) {\n        if ((options == null ? void 0 : options.throwOnError) === true) {\n          throw error;\n        }\n\n        return undefined;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.cancel = function cancel() {\n    var _this$cancelFetch;\n\n    (_this$cancelFetch = this.cancelFetch) == null ? void 0 : _this$cancelFetch.call(this);\n  };\n\n  _proto.continue = function _continue() {\n    var _this$continueFetch;\n\n    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);\n  };\n\n  _proto.clearTimersObservers = function clearTimersObservers() {\n    this.observers.forEach(function (observer) {\n      observer.clearRefetchInterval();\n    });\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    if (this.staleTimeout) {\n      clearTimeout(this.staleTimeout);\n      this.staleTimeout = undefined;\n    }\n  };\n\n  _proto.clearCacheTimeout = function clearCacheTimeout() {\n    if (this.cacheTimeout) {\n      clearTimeout(this.cacheTimeout);\n      this.cacheTimeout = undefined;\n    }\n  };\n\n  _proto.setData = function setData(updater) {\n    var _this$config$isDataEq, _this$config;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data if needed\n\n    if (this.config.structuralSharing) {\n      data = replaceEqualDeep(prevData, data);\n    } // Use prev data if an isDataEqual function is defined and returns `true`\n\n\n    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {\n      data = prevData;\n    }\n\n    var isStale = this.config.staleTime === 0; // Try to determine if more data can be fetched\n\n    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      data: data,\n      isStale: isStale,\n      canFetchMore: canFetchMore\n    });\n    this.rescheduleStaleTimeout();\n  };\n\n  _proto.clear = function clear() {\n    this.clearStaleTimeout();\n    this.clearCacheTimeout();\n    this.clearTimersObservers();\n    this.cancel();\n    delete this.queryCache.queries[this.queryHash];\n    this.notifyGlobalListeners(this);\n  };\n\n  _proto.isEnabled = function isEnabled() {\n    return this.observers.some(function (observer) {\n      return observer.config.enabled;\n    });\n  };\n\n  _proto.onWindowFocus = function onWindowFocus() {\n    if (this.state.isStale && this.observers.some(function (observer) {\n      return observer.config.enabled && observer.config.refetchOnWindowFocus;\n    })) {\n      this.fetch();\n    }\n\n    this.continue();\n  };\n\n  _proto.onOnline = function onOnline() {\n    if (this.state.isStale && this.observers.some(function (observer) {\n      return observer.config.enabled && observer.config.refetchOnReconnect;\n    })) {\n      this.fetch();\n    }\n\n    this.continue();\n  };\n\n  _proto.subscribe = function subscribe(listener) {\n    var observer = new QueryObserver(_extends({\n      queryCache: this.queryCache,\n      queryKey: this.queryKey\n    }, this.config));\n    observer.subscribe(listener);\n    return observer;\n  };\n\n  _proto.subscribeObserver = function subscribeObserver(observer) {\n    this.observers.push(observer); // Stop the query from being garbage collected\n\n    this.clearCacheTimeout();\n  };\n\n  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel();\n      }\n    }\n\n    this.rescheduleGarbageCollection();\n  };\n\n  _proto.tryFetchData = function tryFetchData(config, fn) {\n    try {\n      var _this7 = this;\n\n      return new Promise(function (outerResolve, outerReject) {\n        var resolved = false;\n        var continueLoop;\n        var cancelTransport;\n\n        var done = function done() {\n          resolved = true;\n          delete _this7.cancelFetch;\n          delete _this7.continueFetch;\n          delete _this7.isTransportCancelable; // End loop if currently paused\n\n          continueLoop == null ? void 0 : continueLoop();\n        };\n\n        var resolve = function resolve(value) {\n          done();\n          outerResolve(value);\n        };\n\n        var reject = function reject(value) {\n          done();\n          outerReject(value);\n        }; // Create callback to cancel this fetch\n\n\n        _this7.cancelFetch = function () {\n          reject(new CancelledError());\n\n          try {\n            cancelTransport == null ? void 0 : cancelTransport();\n          } catch (_unused) {}\n        }; // Create callback to continue this fetch\n\n\n        _this7.continueFetch = function () {\n          continueLoop == null ? void 0 : continueLoop();\n        }; // Create loop function\n\n\n        var run = _async(function () {\n          return _catch$1(function () {\n            // Execute query\n            var promiseOrValue = fn(); // Check if the transport layer support cancellation\n\n            if (isCancelable(promiseOrValue)) {\n              cancelTransport = function cancelTransport() {\n                promiseOrValue.cancel();\n              };\n\n              _this7.isTransportCancelable = true;\n            } // Await data\n\n\n            return _await$1(promiseOrValue, function (_promiseOrValue) {\n              resolve(_promiseOrValue);\n            });\n          }, function (error) {\n            // Stop if the fetch is already resolved\n            if (resolved) {\n              return;\n            } // Do we need to retry the request?\n\n\n            var failureCount = _this7.state.failureCount;\n            var retry = config.retry,\n                retryDelay = config.retryDelay;\n            var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n            if (!shouldRetry) {\n              // We are done if the query does not need to be retried\n              reject(error);\n              return;\n            } // Increase the failureCount\n\n\n            _this7.dispatch({\n              type: ActionType.Failed\n            }); // Delay\n\n\n            return _await$1(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {\n              // Pause retry if the document is not visible or when the device is offline\n              return _invoke(function () {\n                if (!isDocumentVisible() || !isOnline()) {\n                  return _awaitIgnored(new Promise(function (continueResolve) {\n                    continueLoop = continueResolve;\n                  }));\n                }\n              }, function () {\n                if (!resolved) {\n                  run();\n                }\n              }); // Try again if not resolved yet\n            });\n          });\n        }); // Start loop\n\n\n        run();\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetch = function fetch(options) {\n    try {\n      var _this9 = this;\n\n      // If we are already fetching, return current promise\n      if (_this9.promise) {\n        return _this9.promise;\n      } // Store reference to the config that initiated this fetch\n\n\n      var config = _this9.config; // Check if there is a query function\n\n      if (!config.queryFn) {\n        return;\n      } // Get the query function params\n\n\n      var filter = config.queryFnParamsFilter;\n      var params = filter ? filter(_this9.queryKey) : _this9.queryKey;\n      _this9.promise = _async(function () {\n        return _catch$1(function () {\n          var data;\n          return _invoke(function () {\n            if (config.infinite) {\n              return _await$1(_this9.startInfiniteFetch(config, params, options), function (_this9$startInfiniteF) {\n                data = _this9$startInfiniteF;\n              });\n            } else {\n              return _await$1(_this9.startFetch(config, params, options), function (_this9$startFetch) {\n                data = _this9$startFetch;\n              });\n            }\n          }, function () {\n            // Set success state\n            _this9.setData(data); // Cleanup\n\n\n            delete _this9.promise; // Return data\n\n            return data;\n          });\n        }, function (error) {\n          // Set error state\n          _this9.dispatch({\n            type: ActionType.Error,\n            error: error\n          }); // Log error\n\n\n          if (!isCancelledError(error)) {\n            Console.error(error);\n          } // Cleanup\n\n\n          delete _this9.promise; // Propagate error\n\n          throw error;\n        });\n      })();\n      return _this9.promise;\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startFetch = function startFetch(config, params, _options) {\n    try {\n      var _this11 = this;\n\n      // Create function to fetch the data\n      var fetchData = function fetchData() {\n        return config.queryFn.apply(void 0, params);\n      }; // Set to fetching state if not already in it\n\n\n      if (!_this11.state.isFetching) {\n        _this11.dispatch({\n          type: ActionType.Fetch\n        });\n      } // Try to fetch the data\n\n\n      return _this11.tryFetchData(config, fetchData);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {\n    try {\n      var _this13 = this;\n\n      var fetchMore = options == null ? void 0 : options.fetchMore;\n\n      var _ref = fetchMore || {},\n          previous = _ref.previous,\n          fetchMoreVariable = _ref.fetchMoreVariable;\n\n      var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;\n      var prevPages = _this13.state.data || []; // Create function to fetch a page\n\n      var fetchPage = _async(function (pages, prepend, cursor) {\n        var lastPage = getLastPage(pages, prepend);\n\n        if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {\n          cursor = config.getFetchMore(lastPage, pages);\n        }\n\n        return _await$1(config.queryFn.apply(void 0, params.concat([cursor])), function (page) {\n          return prepend ? [page].concat(pages) : [].concat(pages, [page]);\n        });\n      }); // Create function to fetch the data\n\n\n      var fetchData = function fetchData() {\n        if (isFetchingMore) {\n          return fetchPage(prevPages, previous, fetchMoreVariable);\n        } else if (!prevPages.length) {\n          return fetchPage([]);\n        } else {\n          var promise = fetchPage([]);\n\n          for (var i = 1; i < prevPages.length; i++) {\n            promise = promise.then(fetchPage);\n          }\n\n          return promise;\n        }\n      }; // Set to fetching state if not already in it\n\n\n      if (!_this13.state.isFetching) {\n        _this13.dispatch({\n          type: ActionType.Fetch,\n          isFetchingMore: isFetchingMore\n        });\n      } // Try to get the data\n\n\n      return _this13.tryFetchData(config, fetchData);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    });\n  };\n\n  return Query;\n}();\n\nfunction getLastPage(pages, previous) {\n  return previous ? pages[0] : pages[pages.length - 1];\n}\n\nfunction hasMorePages(config, pages, previous) {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));\n  }\n\n  return undefined;\n}\n\nfunction getDefaultState(config) {\n  var _config$initialStale;\n\n  var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var hasInitialData = typeof initialData !== 'undefined';\n  var isStale = !config.enabled || (typeof config.initialStale === 'function' ? config.initialStale() : (_config$initialStale = config.initialStale) != null ? _config$initialStale : !hasInitialData);\n  var initialStatus = hasInitialData ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return _extends({}, getStatusProps(initialStatus), {\n    error: null,\n    isFetched: false,\n    isFetching: initialStatus === QueryStatus.Loading,\n    isFetchingMore: false,\n    failureCount: 0,\n    isStale: isStale,\n    data: initialData,\n    updatedAt: hasInitialData ? Date.now() : 0,\n    canFetchMore: hasMorePages(config, initialData)\n  });\n}\n\nfunction queryReducer(state, action) {\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.MarkStale:\n      return _extends({}, state, {\n        isStale: true\n      });\n\n    case ActionType.Fetch:\n      var status = typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading;\n      return _extends({}, state, getStatusProps(status), {\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        failureCount: 0\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, getStatusProps(QueryStatus.Success), {\n        data: action.data,\n        error: null,\n        isStale: action.isStale,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, getStatusProps(QueryStatus.Error), {\n        error: action.error,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        isStale: true,\n        failureCount: state.failureCount + 1,\n        throwInErrorBoundary: true\n      });\n\n    default:\n      return state;\n  }\n}\n\n// CLASS\nfunction _empty$1() {}\n\nfunction _awaitIgnored$1(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty$1) : Promise.resolve();\n  }\n}\n\nfunction _catch$2(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _invoke$1(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _rethrow(thrown, value) {\n  if (thrown) throw value;\n  return value;\n}\n\nfunction _finallyRethrows(body, finalizer) {\n  try {\n    var result = body();\n  } catch (e) {\n    return finalizer(true, e);\n  }\n\n  if (result && result.then) {\n    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n  }\n\n  return finalizer(false, result);\n}\n\nvar QueryCache = /*#__PURE__*/function () {\n  function QueryCache(config) {\n    this.config = config || {}; // A frozen cache does not add new queries to the cache\n\n    this.globalListeners = [];\n    this.queries = {};\n    this.isFetching = 0;\n  }\n\n  var _proto = QueryCache.prototype;\n\n  _proto.notifyGlobalListeners = function notifyGlobalListeners(query) {\n    var _this = this;\n\n    this.isFetching = Object.values(this.queries).reduce(function (acc, query) {\n      return query.state.isFetching ? acc + 1 : acc;\n    }, 0);\n    this.globalListeners.forEach(function (d) {\n      return d(_this, query);\n    });\n  };\n\n  _proto.getDefaultConfig = function getDefaultConfig() {\n    return this.config.defaultConfig;\n  };\n\n  _proto.getDefaultedQueryConfig = function getDefaultedQueryConfig$1(config) {\n    return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {\n      queryCache: this\n    });\n  };\n\n  _proto.subscribe = function subscribe(listener) {\n    var _this2 = this;\n\n    this.globalListeners.push(listener);\n    return function () {\n      _this2.globalListeners.splice(_this2.globalListeners.indexOf(listener), 1);\n    };\n  };\n\n  _proto.clear = function clear(options) {\n    Object.values(this.queries).forEach(function (query) {\n      return query.clear();\n    });\n    this.queries = {};\n\n    if (options == null ? void 0 : options.notify) {\n      this.notifyGlobalListeners();\n    }\n  };\n\n  _proto.getQueries = function getQueries(predicate, options) {\n    if (predicate === true) {\n      return Object.values(this.queries);\n    }\n\n    var predicateFn;\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate;\n    } else {\n      var _config = this.getDefaultedQueryConfig();\n\n      var _ref = _config.queryKeySerializerFn(predicate),\n          queryHash = _ref[0],\n          _queryKey = _ref[1];\n\n      predicateFn = function predicateFn(d) {\n        return (options == null ? void 0 : options.exact) ? d.queryHash === queryHash : deepIncludes(d.queryKey, _queryKey);\n      };\n    }\n\n    return Object.values(this.queries).filter(predicateFn);\n  };\n\n  _proto.getQuery = function getQuery(predicate) {\n    return this.getQueries(predicate, {\n      exact: true\n    })[0];\n  };\n\n  _proto.getQueryData = function getQueryData(predicate) {\n    var _this$getQuery;\n\n    return (_this$getQuery = this.getQuery(predicate)) == null ? void 0 : _this$getQuery.state.data;\n  };\n\n  _proto.removeQueries = function removeQueries(predicate, options) {\n    this.getQueries(predicate, options).forEach(function (query) {\n      return query.clear();\n    });\n  };\n\n  _proto.cancelQueries = function cancelQueries(predicate, options) {\n    this.getQueries(predicate, options).forEach(function (query) {\n      return query.cancel();\n    });\n  };\n\n  _proto.invalidateQueries = function invalidateQueries(predicate, options) {\n    try {\n      var _this4 = this;\n\n      var _ref2 = options || {},\n          _ref2$refetchActive = _ref2.refetchActive,\n          refetchActive = _ref2$refetchActive === void 0 ? true : _ref2$refetchActive,\n          _ref2$refetchInactive = _ref2.refetchInactive,\n          refetchInactive = _ref2$refetchInactive === void 0 ? false : _ref2$refetchInactive,\n          throwOnError = _ref2.throwOnError;\n\n      return _catch$2(function () {\n        return _awaitIgnored$1(Promise.all(_this4.getQueries(predicate, options).map(function (query) {\n          if (query.observers.length) {\n            if (refetchActive && query.isEnabled()) {\n              return query.fetch();\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch();\n            }\n          }\n\n          return query.invalidate();\n        })));\n      }, function (err) {\n        if (throwOnError) {\n          throw err;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.resetErrorBoundaries = function resetErrorBoundaries() {\n    this.getQueries(true).forEach(function (query) {\n      query.state.throwInErrorBoundary = false;\n    });\n  };\n\n  _proto.buildQuery = function buildQuery(userQueryKey, queryConfig) {\n    var _this5 = this;\n\n    var config = this.getDefaultedQueryConfig(queryConfig);\n\n    var _ref3 = config.queryKeySerializerFn(userQueryKey),\n        queryHash = _ref3[0],\n        queryKey = _ref3[1];\n\n    var query;\n\n    if (this.queries[queryHash]) {\n      query = this.queries[queryHash];\n      query.updateConfig(config);\n    }\n\n    if (!query) {\n      query = new Query({\n        queryCache: this,\n        queryKey: queryKey,\n        queryHash: queryHash,\n        config: config,\n        notifyGlobalListeners: function notifyGlobalListeners(query) {\n          _this5.notifyGlobalListeners(query);\n        }\n      });\n\n      if (!this.config.frozen) {\n        this.queries[queryHash] = query;\n        this.notifyGlobalListeners(query);\n      }\n    }\n\n    return query;\n  } // Parameter syntax with optional prefetch options\n  ;\n\n  // Implementation\n  _proto.prefetchQuery = function prefetchQuery() {\n    try {\n      var _this7 = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {\n        args[3] = args[1];\n        args[1] = undefined;\n        args[2] = undefined;\n      }\n\n      var _getQueryArgs = getQueryArgs(args),\n          _queryKey2 = _getQueryArgs[0],\n          _config2 = _getQueryArgs[1],\n          _options = _getQueryArgs[2]; // https://github.com/tannerlinsley/react-query/issues/652\n\n\n      var configWithoutRetry = _extends({\n        retry: false\n      }, _config2);\n\n      var _query;\n\n      return _finallyRethrows(function () {\n        return _catch$2(function () {\n          _query = _this7.buildQuery(_queryKey2, configWithoutRetry);\n          return _invoke$1(function () {\n            if ((_options == null ? void 0 : _options.force) || _query.state.isStale) {\n              return _awaitIgnored$1(_query.fetch());\n            }\n          }, function () {\n            return _query.state.data;\n          });\n        }, function (error) {\n          if (_options == null ? void 0 : _options.throwOnError) {\n            throw error;\n          }\n        });\n      }, function (_wasThrown, _result2) {\n        if (_query) {\n          // When prefetching, no observer is tied to the query,\n          // so to avoid immediate garbage collection of the still\n          // empty query, we wait with activating timeouts until\n          // the prefetch is done\n          _query.activateTimeouts();\n        }\n\n        return _rethrow(_wasThrown, _result2);\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.setQueryData = function setQueryData(queryKey, updater, config) {\n    var query = this.getQuery(queryKey);\n\n    if (query) {\n      query.setData(updater);\n      return;\n    }\n\n    var newQuery = this.buildQuery(queryKey, _extends({\n      initialStale: typeof (config == null ? void 0 : config.staleTime) === 'undefined',\n      initialData: functionalUpdate(updater, undefined)\n    }, config));\n    newQuery.activateTimeouts();\n  };\n\n  return QueryCache;\n}();\nvar defaultQueryCache = makeQueryCache({\n  frozen: isServer\n});\nvar queryCaches = [defaultQueryCache];\nfunction makeQueryCache(config) {\n  return new QueryCache(config);\n}\nfunction onVisibilityOrOnlineChange(isOnlineChange) {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(function (queryCache) {\n      queryCache.getQueries(function (query) {\n        if (isOnlineChange) {\n          query.onOnline();\n        } else {\n          query.onWindowFocus();\n        }\n      });\n    });\n  }\n}\n\nvar setFocusHandler = createSetHandler(function () {\n  return onVisibilityOrOnlineChange(false);\n});\nsetFocusHandler(function (handleFocus) {\n  var _window;\n\n  if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {\n    return;\n  } // Listen to visibillitychange and focus\n\n\n  window.addEventListener('visibilitychange', handleFocus, false);\n  window.addEventListener('focus', handleFocus, false);\n  return function () {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus);\n    window.removeEventListener('focus', handleFocus);\n  };\n});\n\nvar setOnlineHandler = createSetHandler(function () {\n  return onVisibilityOrOnlineChange(true);\n});\nsetOnlineHandler(function (handleOnline) {\n  var _window;\n\n  if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {\n    return;\n  } // Listen to online\n\n\n  window.addEventListener('online', handleOnline, false);\n  return function () {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('online', handleOnline);\n  };\n});\n\nvar queryCacheContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(defaultQueryCache);\nvar useQueryCache = function useQueryCache() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useContext(queryCacheContext);\n};\nvar ReactQueryCacheProvider = function ReactQueryCacheProvider(_ref) {\n  var queryCache = _ref.queryCache,\n      children = _ref.children;\n  var resolvedQueryCache = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {\n    return queryCache || makeQueryCache();\n  }, [queryCache]);\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {\n    queryCaches.push(resolvedQueryCache);\n    return function () {\n      // remove the cache from the active list\n      var i = queryCaches.indexOf(resolvedQueryCache);\n\n      if (i > -1) {\n        queryCaches.splice(i, 1);\n      } // if the resolvedQueryCache was created by us, we need to tear it down\n\n\n      if (queryCache == null) {\n        resolvedQueryCache.clear({\n          notify: false\n        });\n      }\n    };\n  }, [resolvedQueryCache, queryCache]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(queryCacheContext.Provider, {\n    value: resolvedQueryCache\n  }, children);\n};\n\nvar configContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(undefined);\nfunction useContextConfig() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useContext(configContext);\n}\nvar ReactQueryConfigProvider = function ReactQueryConfigProvider(_ref) {\n  var config = _ref.config,\n      children = _ref.children;\n  var parentConfig = useContextConfig();\n  var mergedConfig = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {\n    return parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config;\n  }, [config, parentConfig]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(configContext.Provider, {\n    value: mergedConfig\n  }, children);\n};\n\nfunction useGetLatest(obj) {\n  var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(obj);\n  ref.current = obj;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {\n    return ref.current;\n  }, []);\n}\n\nfunction useIsMounted() {\n  var mountedRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(false);\n  var isMounted = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {\n    return mountedRef.current;\n  }, []);\n  (react__WEBPACK_IMPORTED_MODULE_0___default())[isServer ? 'useEffect' : 'useLayoutEffect'](function () {\n    mountedRef.current = true;\n    return function () {\n      mountedRef.current = false;\n    };\n  }, []);\n  return isMounted;\n}\n\nfunction useMountedCallback(callback) {\n  var isMounted = useIsMounted();\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {\n    if (isMounted()) {\n      return callback.apply(void 0, arguments);\n    }\n  }, [callback, isMounted]);\n}\n/**\n * This hook is a safe useState version which schedules state updates in microtasks\n * to prevent updating a component state while React is rendering different components\n * or when the component is not mounted anymore.\n */\n\nfunction useSafeState(initialState) {\n  var isMounted = useIsMounted();\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(initialState),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var safeSetState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (value) {\n    scheduleMicrotask(function () {\n      if (isMounted()) {\n        setState(value);\n      }\n    });\n  }, [isMounted]);\n  return [state, safeSetState];\n}\nfunction useRerenderer() {\n  var _useSafeState = useSafeState({}),\n      setState = _useSafeState[1];\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {\n    return setState({});\n  }, [setState]);\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  Promise.resolve().then(callback).catch(function (error) {\n    return setTimeout(function () {\n      throw error;\n    });\n  });\n}\n\nfunction useIsFetching() {\n  var queryCache = useQueryCache();\n\n  var _useSafeState = useSafeState(queryCache.isFetching),\n      isFetching = _useSafeState[0],\n      setIsFetching = _useSafeState[1];\n\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {\n    return queryCache.subscribe(function () {\n      setIsFetching(queryCache.isFetching);\n    });\n  }, [queryCache, setIsFetching]);\n  return isFetching;\n}\n\nfunction useDefaultedMutationConfig(config) {\n  var contextConfig = useContextConfig();\n  var contextQueryCache = useQueryCache();\n  var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;\n  var queryCacheConfig = queryCache.getDefaultConfig();\n  return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {\n    queryCache: queryCache\n  });\n}\n\nfunction _await$2(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar ActionType$1;\n\nfunction _catch$3(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async$1(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n(function (ActionType) {\n  ActionType[\"Reset\"] = \"Reset\";\n  ActionType[\"Loading\"] = \"Loading\";\n  ActionType[\"Resolve\"] = \"Resolve\";\n  ActionType[\"Reject\"] = \"Reject\";\n})(ActionType$1 || (ActionType$1 = {}));\n\n// HOOK\nvar getDefaultState$1 = function getDefaultState() {\n  return _extends({}, getStatusProps(QueryStatus.Idle), {\n    data: undefined,\n    error: null\n  });\n};\n\nfunction mutationReducer(state, action) {\n  switch (action.type) {\n    case ActionType$1.Reset:\n      return getDefaultState$1();\n\n    case ActionType$1.Loading:\n      return _extends({}, getStatusProps(QueryStatus.Loading), {\n        data: undefined,\n        error: null\n      });\n\n    case ActionType$1.Resolve:\n      return _extends({}, getStatusProps(QueryStatus.Success), {\n        data: action.data,\n        error: null\n      });\n\n    case ActionType$1.Reject:\n      return _extends({}, getStatusProps(QueryStatus.Error), {\n        data: undefined,\n        error: action.error\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction useMutation(mutationFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  config = useDefaultedMutationConfig(config);\n  var getConfig = useGetLatest(config);\n\n  var _React$useReducer = react__WEBPACK_IMPORTED_MODULE_0___default().useReducer(mutationReducer, null, getDefaultState$1),\n      state = _React$useReducer[0],\n      unsafeDispatch = _React$useReducer[1];\n\n  var dispatch = useMountedCallback(unsafeDispatch);\n  var getMutationFn = useGetLatest(mutationFn);\n  var latestMutationRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n  var mutate = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(_async$1(function (variables, mutateConfig) {\n    if (mutateConfig === void 0) {\n      mutateConfig = {};\n    }\n\n    var config = getConfig();\n    var mutationId = uid();\n    latestMutationRef.current = mutationId;\n\n    var isLatest = function isLatest() {\n      return latestMutationRef.current === mutationId;\n    };\n\n    var snapshotValue;\n    return _catch$3(function () {\n      dispatch({\n        type: ActionType$1.Loading\n      });\n      return _await$2(config.onMutate == null ? void 0 : config.onMutate(variables), function (_config$onMutate) {\n        snapshotValue = _config$onMutate;\n        return _await$2(getMutationFn()(variables), function (data) {\n          if (isLatest()) {\n            dispatch({\n              type: ActionType$1.Resolve,\n              data: data\n            });\n          }\n\n          return _await$2(config.onSuccess == null ? void 0 : config.onSuccess(data, variables), function () {\n            return _await$2(mutateConfig.onSuccess == null ? void 0 : mutateConfig.onSuccess(data, variables), function () {\n              return _await$2(config.onSettled == null ? void 0 : config.onSettled(data, null, variables), function () {\n                return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(data, null, variables), function () {\n                  return data;\n                });\n              });\n            });\n          });\n        });\n      });\n    }, function (error) {\n      Console.error(error);\n      return _await$2(config.onError == null ? void 0 : config.onError(error, variables, snapshotValue), function () {\n        return _await$2(mutateConfig.onError == null ? void 0 : mutateConfig.onError(error, variables, snapshotValue), function () {\n          return _await$2(config.onSettled == null ? void 0 : config.onSettled(undefined, error, variables, snapshotValue), function () {\n            return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(undefined, error, variables, snapshotValue), function () {\n              var _mutateConfig$throwOn;\n\n              if (isLatest()) {\n                dispatch({\n                  type: ActionType$1.Reject,\n                  error: error\n                });\n              }\n\n              if ((_mutateConfig$throwOn = mutateConfig.throwOnError) != null ? _mutateConfig$throwOn : config.throwOnError) {\n                throw error;\n              }\n            });\n          });\n        });\n      });\n    });\n  }), [dispatch, getConfig, getMutationFn]);\n  var reset = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {\n    dispatch({\n      type: ActionType$1.Reset\n    });\n  }, [dispatch]);\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {\n    var _getConfig = getConfig(),\n        suspense = _getConfig.suspense,\n        useErrorBoundary = _getConfig.useErrorBoundary;\n\n    if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {\n      throw state.error;\n    }\n  }, [getConfig, state.error]);\n  return [mutate, _extends({}, state, {\n    reset: reset\n  })];\n}\n\nfunction useDefaultedQueryConfig(config) {\n  var contextConfig = useContextConfig();\n  var contextQueryCache = useQueryCache();\n  var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;\n  var queryCacheConfig = queryCache.getDefaultConfig();\n  return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {\n    queryCache: queryCache\n  });\n}\n\nfunction useBaseQuery(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  config = useDefaultedQueryConfig(config); // Make a rerender function\n\n  var rerender = useRerenderer(); // Create query observer\n\n  var observerRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n  var firstRender = !observerRef.current;\n  var observer = observerRef.current || new QueryObserver(config);\n  observerRef.current = observer; // Subscribe to the observer\n\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {\n    return observer.subscribe(function () {\n      rerender();\n    });\n  }, [observer, rerender]); // Update config\n\n  if (!firstRender) {\n    observer.updateConfig(config);\n  }\n\n  var result = observer.getCurrentResult(); // Handle suspense\n\n  if (config.suspense || config.useErrorBoundary) {\n    if (result.isError && result.query.state.throwInErrorBoundary) {\n      throw result.error;\n    }\n\n    if (config.enabled && config.suspense && !result.isSuccess) {\n      var unsubscribe = observer.subscribe();\n      throw observer.fetch().finally(unsubscribe);\n    }\n  }\n\n  return result;\n}\n\n// Implementation\nfunction useQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var config = getQueryArgs(args)[1];\n  return useBaseQuery(config);\n}\n\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n// TYPES\n\n// Implementation\nfunction usePaginatedQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var config = getQueryArgs(args)[1];\n  var result = useBaseQuery(_extends({}, config, {\n    keepPreviousData: true\n  }));\n  return _extends({}, result, {\n    resolvedData: result.data,\n    latestData: result.query.state.data === result.data ? result.data : undefined\n  });\n}\n\n// Implementation\nfunction useInfiniteQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var config = getQueryArgs(args)[1];\n  return useBaseQuery(_extends({}, config, {\n    infinite: true\n  }));\n}\n\n\n//# sourceMappingURL=react-query.mjs.map\n\n\n//# sourceURL=webpack://yd-react-generator/./node_modules/react-query/dist/react-query.mjs?");

/***/ })

}]);