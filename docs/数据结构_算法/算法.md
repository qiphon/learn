# 算法

### 什么是算法？

算法是完成某个特定任务的过程。通常数据结构作为工具来辅助执行算法。所以有一个
广为流传的公式：程序 = 数据结构 + 算法

- 算法不是数学，但是可以用数学来描述
- 我们要做的事情，这个过程本身就是一个算法
- 我们最常用的增删改查是算法的一部分
- 算法可以用自然语言、流程图、伪代码和计算机语言等手段来表示
- 在面向对象语言中，算法通常通过类的方法实现

- 每天都在接触的算法
  - 排序算法
  - 查找算法
  - 推荐算法
  - 贪心算法

### 算法的特征

- 有穷性： 算法必须能在执行有限个步骤之后终止
- 确切性：每一步骤必须有确切的定义
- 输入项：有 0 个或多个输入，用来规定初始情况，所谓 0 个就是输入是指算法本身定出了初始条件
- 输出项：有一个或多个输出，是对输入数据处理后的结果。没有输出的算法毫无意义
- 可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，每个计算步都可以在有限的时间内完成（也称之为有效性）

### 怎样衡量算法的好坏

- 算法的好坏主要通过算法复杂度来衡量

  - 时间复杂度（效率）

    基本操作步骤，要执行的次数（不依赖具体硬件和执行环境）

  - 空间复杂度（占用额外的内存空间，是一个相对指标。以要处理的数据的最小单位为基准）

- 正确性
- 可读性
- 健壮性（容错是不是很好）

#### 复杂度 (由上到下依次增高)

- 常数阶 O（1）
- 对数阶 O(logN)
- 线性阶 O（n）
- 线性对数阶 O（nlogN）
- 平方阶 O（n^2）
- 立方阶 O（n^3）
- k 次方阶 O（n^k）
- 指数阶 O（2^n）

#### 计算算法复查度

- 随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越低
- 一般算法复杂度分析的时候，遵循下面的技巧

  - 有几重循环，一般来说一重就是 O（n），两重就是 O（n^2），以此类推
  - 如果有二分，则为 O（logN）
  - 保留最高项，去除常数项

  ```js
  let i = 0; // 执行 1 次
  while (i < n) {
    // 执行 n 次
    console.log(i); // 执行 n 次
    i++; // n 次
  }
  // 结果 1+ n + n + n = 1 + 3n
  // 取出常数项 O(n)

  let number = 1; // 1
  while (number < n) {
    // logN
    number *= 2; // logN
  }

  // 所以结果 O(logN)

  for (let i = 0; i < n; i++) {
    // n
    for (let j = 0; j < n; j++) {
      // n^2
      console.log("for"); // n^2
    }
  }

  // 结果 O（n^2）
  ```

### 基本算法

- 枚举
- 递归
- 基本排序
- 基本查找

#### 枚举

- 核心思想：枚举出所有可能
- 本质： 就是从所有候选答案中去搜索正确的解，使用该算法需要满足 2 个条件

  - 预知候选结果数量
  - 候选答案的范围在求解之前必须有一个特定的集合

- 特点：
  - 枚举算法简单粗暴，暴力枚举所有可能，尽可能地尝试所有方法
  - 速度可能很慢，却是我们最应该优先考虑的
  - 实现最简单，并且得到的结果总是正确的

#### 递归

- 核心思想：通过重复将问题分解为同类的子问题而解决问题的方法
- 特点：

  - 函数可以通过调用自身来进行递归
  - 递归可以完全取代循环（循环和递归执行的结果对等，基本可以相互转换）

- 递归由 2 部分组成
  - 递归主体，就是循环解决问题的代码
  - 递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出。

#### 排序算法

- 冒泡 最佳时间 n 平均时间 n^2 最差时间复杂度 n^2 空间复杂度 1 稳定 yes
- 插入 最佳时间 n 平均时间 n^2 最差时间复杂度 n^2 空间复杂度 1 稳定 yes
- 选择 最佳时间 n^2 平均时间 n^2 最差时间复杂度 n^2 空间复杂度 1 稳定 no
- 二叉树 最佳时间 nlogn 平均时间 nlogn 最差时间复杂度 nlogn 空间复杂度 1 稳定 yes
- 快速排序 最佳时间 nlogn 平均时间 nlogn 最差时间复杂度 n^2 空间复杂度 logn ~ n 稳定 no
- 堆排序 最佳时间 nlogn 平均时间 nlogn 最差时间复杂度 nlogn 空间复杂度 1 稳定 no
- 快速排序 最佳时间 nlogn 平均时间 nlogn 最差时间复杂度 n^2 空间复杂度 1 稳定 no

稳定性：得到的结果顺序不能保证每次都是一致的，比如排序一个班级内学生的年龄（从小到大），由于年龄可能相同
所有同年龄的人可能第一次小张在前面，第二次小王在前面

查找算法

```
查找算法                 平均时间复杂度     查找条件
顺序查找                 n                无序或有序队列
二分查找（折半查找）       nlogn            有序数组
二叉排序树查找            nlogn            二叉排序树
哈西表算法（散列表）       1                先创建哈西表
分块查找                 nlogn            无序或或有序队列
```

### 怎样养成算法思维

- 结果是什么？
- 步骤是什么？
- 判断结果的标准是什么？

- 化繁为简

  - 很难在第一时间内得到正确的思路，这时候可以尝试一种由简至繁的思路。首先把问题规模缩小到非常容易解答的地步。
    用来解决动态规划问题
  - 分治

    - 把问题分为两半，变成 2 个与原来问题同构的问题
    - 在尝试这种思路时，其实只需要考虑 2 个问题：
      - 一分为二以后，问题是否被简化了
      - 根据一分为二的两个问题的解，能否方便地得出整个问题的解

  - 化虚为实
    - 使用另外一种形式进行替换

### 解决算法面试问题

- 面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，挺好关键词，比如： 有序的数列做查找、要求算法复杂度是 O（logN）
  这类一般就是二分的思想
- 算法题目的解题思路分为一下四步：
  - 先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤
  - 根据解题步骤编写程序，优先将特殊情况做好判读处理，比如一个大数组的问题，如果数组为两个数长度的情况
  - 检验程序的正确性
  - 是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以提现技术能力

## 一些重要的算法

### [A 星算法](https://zh.wikipedia.org/zh-cn/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95)

在图形平面上，有一堆点，求从点 A 到点 B 的最短路径。

该算法像 Dijkstra 算法一样，可以找到一条最短路径；也像 BFS 一样，进行启发式的搜索。

### [beam search](https://en.wikipedia.org/wiki/Beam_search)

束搜索(beam search) 方法是解决优化问题的一种启发式方法。它使用启发式方法估计 k 个最好的路径,仅从这 k 个路径出发向下搜索,即每一层只有满意的结点会被保留,其它的结点则被永久抛弃,从而比分枝定界法能大大节省运行时间。

### [二分查找算法（英语：binary search algorithm）](https://en.wikipedia.org/wiki/Binary_search)

搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

### [分支界定，Branch and bound](https://en.wikipedia.org/wiki/Branch_and_bound)

分支定界算法可以视为一种对可行解进行穷举的算法，但是和穷举法所不同的是，分支定界算法在对某一分支进行检索之前会先算出该分支的上界或下界，如果界限不比目前最佳解更好，那么该分支就会被舍弃，从而节约了大量的时间。

分支定界算法非常依赖合适的上界或下界，如果无法找到合适的界限，该算法将会退化为穷举法

### [数据压缩](https://en.wikipedia.org/wiki/Data_compression)

### [Diffie–Hellman 密钥协商](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)

Diffie–Hellman key exchange，简称“D–H”， 是一种安全协议。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。

### [Dijkstra’s 算法](https://zh.wikipedia.org/zh-cn/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95)

迪科斯彻算法（Dijkstra）是由荷兰计算机科学家艾兹格·迪科斯彻（Edsger Wybe Dijkstra）发明的。算法解决的是有向图中单个源点到其他顶点的最短路径问题。举例来说，如果图中的顶点表示城市，而边上的权重表示著城市间开车行经的距离，迪科斯彻算法可以用来找到两个城市之间的最短路径。

### [动态规划](https://zh.wikipedia.org/zh-cn/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

动态规划是一种在数学和计算机科学中使用的，用于求解包含重叠子问题的最优化问题的方法。其基本思想是，将原问题分解为相似的子问题，在求解的过程中通过子问题的解求出原问题的解。动态规划的思想是多种算法的基础，被广泛应用于计算机科学和工程领域。比较著名的应用实例有：求解最短路径问题，背包问题，项目管理，网络流优化等。这里也有一篇文章说得比较详细。

### [欧几里得算法（英语：Euclidean algorithm）](https://zh.wikipedia.org/zh-cn/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95)

求两个正整数的最大公约数。

在数学中，辗转相除法，又称欧几里得算法，是求最大公约数的算法。辗转相除法首次出现于欧几里得的《几何原本》（第 VII 卷，命题 i 和 ii）中，而在中国则可以追溯至东汉出现的《九章算术》。

过程看这个演示 https://zh.wikipedia.org/zh-cn/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95#/media/File:Euclidean_algorithm_1071_462.gif

### [最大期望算法](https://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%A4%A7%E6%9C%9F%E6%9C%9B%E7%AE%97%E6%B3%95)

### [快速傅里叶变换](https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)

### [哈希函数](https://zh.wikipedia.org/zh-cn/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)

散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（又叫哈希值）（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。[1]好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。

### [堆排序](https://zh.wikipedia.org/zh-cn/%E5%A0%86%E6%8E%92%E5%BA%8F)

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

```
用简单的公式来描述一下堆的定义就是：
大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]

小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]
```

> 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了

### [归并排序](https://zh.wikipedia.org/zh-cn/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)

采用分治法:

分割：递归地把当前序列平均分割成两半。
集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。

### [随机抽样一致算法](https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E6%8A%BD%E6%A8%A3%E4%B8%80%E8%87%B4)

RANSAC 的基本假設是

- 「內群」(inlier, 似乎譯為內點群更加妥當，即正常數據，正確數據)數據可以通過幾組模型的參數來敘述其分佈，而｢離群」(outlier,似乎譯為外點群更加妥當，異常數 ​​ 據)數據則是不適合模型化的數據。
- 數據會受雜訊影響，雜訊指的是離群，例如從極端的雜訊或錯誤解釋有關數據的測量或不正確的假設。
- RANSAC 假定，給定一組（通常很小）的內點群，存在一個程序，這個程序可以估算最佳解釋或最適用於這一數據模型的參數。

### [RSA 加密演算法](https://zh.wikipedia.org/zh-tw/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)

### [并查集](https://zh.wikipedia.org/zh-cn/%E5%B9%B6%E6%9F%A5%E9%9B%86)

并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。

### [List of algorithms (算法列表)](https://en.wikipedia.org/wiki/List_of_algorithms)
