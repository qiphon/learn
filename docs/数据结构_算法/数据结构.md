# 数据结构

### [什么是数据结构](https://mp.weixin.qq.com/s/-gVuQHNopd7-jH_rC7S3ug)

> 我们把焦点从“数据”(一件事)转移到了“结构”(组织)。这是一个微妙但非常重要的细节。换句话说，我们不再关注事物本身，而是关注如何组织事物的过程。

数据结构起源于程序设计，是用计算机来存储、组织数据的方式。数据结构不是使我们学会编码，而是为我们提供一种编程思想，具有更好的思路。

- 广义：数据结构 = 数据存储 + 算法
- 狭义：数据结构 = 数据的存储

### 认识数据结构

数据结构与算法是相互依托的关系。计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，
设计出一个解此数据模型的算法：

- 数据结构 ==> 建筑工程中的建筑设计图
- 算法 ==> 工程中的施工流程图

### 用数据结构做什么

- 程序员的内功心法
- 有效管理数据对象
- 解决处理性能问题
- 面试加分项

### 基本概念

- 数据：只要能输入到计算机的东西都算数据（对客观事物的描述）
- 数据对象：客观对象的具体描述
- 数据元素：能够描述客观世界的最小单位
- 数据项：数据元素中包含的一些必要属性

#### 数据结构

数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的。

- 逻辑结构（表面上的关系）: 反应数据元素之间的逻辑关系
- 存储结构：数据结构在计算机中的表示
- 算法：对数据的操作

```

                                数据结构
----------------------------------------------------------------------------
            按逻辑结构分                              按存储结构分
-----------------------------------------------------------------------------
集合 、       线性结构       、非线性结构 |          顺序存储结构 （在内存中挨着存放）         
--------------------------------------           散列存储结构（一般用于堆上，元素之间无联系）
            一维数组          树                   链式存储结构（通过指针连接前后数据）
            队列             图                   索引存储结构（map，分为2部分内容，索引保存key，
            栈               多维数组              第二部分保存value，一个索引对应一个key）
        

```

#### 基本逻辑结构

- 集合（set）
- 线性结构（array）
- 树状结构（一对多）
- 图状结构（多对多）

### 内存与存储结构

- 内存的原理与构造
- 地址、指针与引用
- 存储结构与内存管理

#### 集合

数据结构中的集合关系类似于数学中的集合

- 集合中的数据是无顺序的
- 集合中的数据不能重复

#### 线性表

线性结构中的数据元素之间是一对一的关系。也就是数据元素一个接一个的排列。

- 用来存放特定的某一个类型的元素
- 物理结构为顺序表和链表

- 线性表的衍生结构 （操作受限的线性元素）
    - 栈

        栈是一种被限制操作的线性表，只能从一头操作

        - 基本操作
            - 入栈
            - 出栈
            - 读取栈顶元素
        - LIFO（last in first out）
        - 用途
            - 解决括号匹配检查
            - 浏览器的后腿或编辑器的undo功能

    - 队列

        只能一头进，另一头出

        - 基本操作
            - 出队
            - 入队
        - FIFO （first in first out）
        - 用途
            - 消息队列、视频弹幕
            - 维护打印任务

    - 串（字符串、流）

- 树 

    树是由若干个有限节点组成的一个具有层次关系的集合

    - 数学基础： 图论
    - 一棵树中每2个节点之间都有且只有一条路线
    - 一颗有n个节点的树有 n-1 条边
    - 边：相邻2个节点的连线
    - 深：根节点为零，没增加一层加一
    - 路径：从一个节点到另一个节点的集合
    - 度：一个父节点包含的节点数量叫度。（没有子节点的节点 度为 0）

    - 树的遍历
        - 先序遍历（深度优先）缩小运问题模
        - 中序遍历（深度优先）
        - 后序遍历（深度优先）
        - 层序遍历（广度优先）

    - 树的衍生
        - 无序树：树中任意节点的子节点之间没有顺序关系（也叫自由树）
        - 有序树：树中任意节点的子节点有顺序关系
        - 二叉树：每个节点最多含有2个子节点
        - 完全二叉树：除了最后一层，其它各层节点树都达到了最大
        - 满二叉树：每一层上的节点树都是最大节点数
        - 霍夫曼树：带权路径最短的二叉树，也叫最优二叉树

- 图

    由定点的集合（不能是空集）和边的集合组成的结构，表现的是多对多的关系

    - 数学基础：图论
    - 几个基本概念：
        - 顶点
        - 边
        - 权
        - 有向图与无向图

### 前端中的数据结构应用

- 核心dom
- 编写前端控件
- 游戏


- 不同类型的数据结构
    书籍，就像数据一样，可以用多种方式组织起来。假如我们有20本书，那么应该怎样组织它们呢?

    如果我们想要在书架上很快的找到一本参考书，不妨这样做：把所有的书都按照字母顺序排列在书架上，当你需要某一本书时，就可以很快的找到它，因为我们知道书籍是按照字母表的顺序摆放的。

    如果我们想按照一个特定的顺序阅读所有的书，比如从第一本读到最后一本，那么我们就应该按照这种顺序把书放置在书架上，并且还需要制定一个规则来约束这种阅读顺序。

    如果我们没有足够的空间把所有的书全都放在一起，就需要一种能够快速找到它们的方式进行组织。比如：家里的不同位置散落着20本书，我们就需要一个有两列的表格，其中第一列列出书的标题，第二列列出其对应的位置。

    到这里我们应该已经清楚了，组织书籍的方法有很多，换句话说有很多种不同的数据结构。用于web开发中的数据结构，就像前面书籍的例子一样，是由我们的需求决定的。

    现在我们知道了，不同的需求还需要依赖不同的数据结构来实现。接下来我们还应该知道，当使用和创建这些数据结构时，并不需要什么高深的编码知识，所有人哪怕是刚入门的小菜鸟都可以创建它。对于前端程序员来讲，只需要了解常用的JavaScript基本类型（例如：Boolean）和引用类型（例如：Object）。

    如果即使我这样解释对你来说也比较难，别担心，通常我会想象有一个集合，这是一种数据结构，就像一个集合一样，啊哈，多么狗血的解释。首先集合不是什么东西，集合是组织数据的一种方式的名字；其次我们要知道，一个集合是用对象创建的。

- 最常见也最重要的数据结构:
    - 栈和队列
    - 单链表和双链表链表
    - 树(深度优先搜索和广度优先搜索)

- [栈](https://mp.weixin.qq.com/s/nymhlqG9oZ_TCxLGBuzSrQ)

    栈和队列是web开发中最常用的两种数据结构。绝大多数用户，甚至包括web开发人员，都不知道这个惊人的事实。如果你是一个程序员，那么请听我讲两个启发性的例子：使用栈来组织数据，来实现文本编辑器的“撤消”操作；使用队列处理数据，实现web浏览器的事件循环处理事件（单击click、悬停hoover等）。

    > 在计算机科学中，栈是一种线性数据结构。如果你理解起来有困难，就像最初的我一样非常困惑，不妨这样认为：一个栈可以对数据按照顺序进行组织和管理。

    要理解这种顺序，我们可以把栈这种结构想象为自助餐厅的一堆盘子，当一个盘子被叠加到一堆盘子上时，原有的盘子保留了它们原来的顺序；同时，当一个新盘子被添加时，它会朝栈的底部方向堆积。每当我们添加一个新盘子时，被称作入栈，这个新盘子处于栈的顶部，也被称作栈顶。

    这个过程会保留每个盘子被添加到栈中的顺序，每次从栈中取出一个盘子时也是一样的。

    - 栈的操作
        - push(data) 添加数据
        - pop() 删除最后添加的数据

    - 栈的属性

        为了实现栈结构，我们将会创建一个名为 Stack 的构造函数。栈的每个实例都有两个属性：_size 和 _storage。

        ```js
        function Stack() {
            this._size = 0;
            this._storage = {};
        }
        ```
        this._storage 属性使栈的每一个实例都具有自己的用来存储数据的容器； this._size 属性反映了当前栈中数据的个数。如果创建了一个新的栈的实例，并且有一个数据被存入栈中，那么 this._size 的值将被增加到1。如果又有数据入栈，this._size 的值将增加到2。如果一个数据从栈中被取出，this._size 的值将会减少为1。

    - 栈的方法(操作)

        我们需要定义可以向栈中添加（入栈）和从栈中取出（出栈）数据的方法。
    
        - push(data)
            1. 每当添加数据时，希望能够增加栈的大小。
            2. 每当添加数据时，希望能够保留它的添加顺序。
            ```sh
            Stack.prototype.push = function(data) {
                // increases the size of our storage
                var size = this._size++;
                // assigns size as a key of storage
                // assigns data as the value of this key
                this._storage[size] = data;
            };
            ```
        - pop()

            1. 使用栈当前的大小获得最后一次添加的数据。 
            2. 删除最后一次添加的数据。 
            3. 使 _this._size 计数减1。 
            4. 返回刚刚删除的数据。

            ```js
            Stack.prototype.pop = function() {
                var size = this._size,
                    deletedData;
                deletedData = this._storage[size];
                delete this._storage[size];
                this.size--;
                return deletedData;
            };
            ```
    - 栈的完整实现

        ```js
        function Stack() {
            this._size = 0;
            this._storage = {};
        }
        Stack.prototype.push = function(data) {
            var size = ++this._size;
            this._storage[size] = data;
        };
        Stack.prototype.pop = function() {
            var size = this._size,
                deletedData;
            if (size) {
                deletedData = this._storage[size];
                delete this._storage[size];
                this._size--;
                return deletedData;
            }
        };
        ```
- [队列](https://mp.weixin.qq.com/s/nXzN7fvXPWyM8yQPzEonfA)

    当我们想要按顺序添加数据或删除数据时，可以使用栈结构。根据它的定义，栈可以只删除最近添加的数据。如果想要删除最早的数据该怎么办呢?这时我们希望使用名为queue的数据结构。

    与栈类似，队列也是一个线性数据结构。与栈不同的是，队列只删除最先添加的数据。

    为了帮助你明白队列这是如何工作的，让我们花点时间举个例子。我们可以把队列想象成为熟食店的售票系统。每个顾客拿一张票，当他们的号码被呼叫时送达。持第一张票的顾客首先接受服务。

    再进一步想象一下，这张票上有一个数字“1”。下一张票上有数字“2”。得到二张票的顾客将会第二个接受服务。（如果我们的售票系统像栈一样运行，最先进入堆栈的客户将会最后一个接受服务！）

    队列的一个更实际的例子是Web浏览器的事件循环。当触发不同事件时，例如单击某个按钮，点击事件将被添加到事件循环队列中，并按照它们进入队列的顺序进行处理。

    现在我们有了队列的概念模型，接下来就定义它的操作。你会注意到，队列的操作和栈非常相似。区别就在被删除的数据在什么地方。

    - enqueue(data) 将数据添加到队列中。
    - dequeue 删除最早加入队列的数据。

    - 队列的属性

        在实现队列的代码中，我们将会创建一个名为 Queue 的构造方法。
        
        接下来添加三个属性：_oldestIndex, _newestIndex, 和 _storage。
        
        ```js
        function Queue() {
            this._oldestIndex = 1;
            this._newestIndex = 1;
            this._storage = {};
        }
        ```
    - 队列的方法

        现在我们将创建队列会用到的三个方法：size(), enqueue(data), 和 dequeue(data)。我将描述每个方法的作用，写出每个方法的代码，然后解释这些代码。

        ##### 方法1/3：size( )

        这个方法有两个作用：

        1. 返回当前队列的长度。

        2. 保持队列中键的正确范围。

            ```js
            Queue.prototype.size = function(){
                return this._newestIndex - this._oldestIndex
            }
            ```
            实现 size() 可能显得微不足道，但你会很快发现并不是这样的。为了理解其原因，我们必须快速重新审视 size() 在栈结构中的实现。

            回想一下栈的概念模型，假设我们把5个盘子添加到一个栈上。我们的栈的大小是5，每个盘子都有一个数字，从1(第一个添加的盘子)到5(最后一个添加的盘子)。如果我们取走三个盘子，就只剩下两个盘子。我们可以简单地用5减去3，得到正确的大小，也就是2。这里是关于栈大小最重要的一点：当前大小相当于从栈顶部的盘子（2）到栈中其他盘子（1）的计数。换句话说，键的范围总是从当前大小到1之间。

            现在，让我们将栈大小的实现应用到队列中。假设有五个顾客从我们的售票系统中取到了票。第一个顾客有一张显示数字1的票，第五个客户有一张显示数字5的票。现在有了一个队列，拿着第一张票的第一位顾客。

            假设第一个客户接受了服务，这张票会从队列中被移除。与栈类似，我们可以通过从5减去1来获得队列的正确大小。那么服务队列中还有4张票。现在出现了一个问题：队列的大小不能对应正确的票号。如果我们从五减去一个，得到大小是4，但是不能使用4来确定当前队列中剩余票的编号范围。我们并不能确定队列中票号的顺序到底是1到4还是2到5。

            这就是 oldestIndex 和 newestIndex 这两个属性 在队列中的用途。所有这一切似乎令人困惑——到现在我仍然会偶尔觉得困惑。下面的例子可以帮助我门理顺所有的逻辑。

            假设我们的熟食店有两个售票系统：

            _newestindex 代表顾客售票系统的票。

            _oldestindex 代表员工售票系统的票。

            对于两个售票系统来说，这是最难掌握的概念：当两个系统中的数字相同时，队列中的每个客户都被处理了，队列是空的。我们将使用下面的场景来加强这种逻辑：

            1. 当顾客买票时，顾客的票号从_newestIndex 得到，票的编号是1。顾客售票系统的下一张票号码是2。

            2. 员工不买票，员工售票系统中当前票的编号是1。

            3. 我们在顾客系统中得到当前的票号2，减去员工系统中的号码1，得到的结果是1。这个数字1表示仍然在队列中没有被删除的票的数量

            4. 员工从它们的售票系统中取票，这张票代表正在被服务的顾客的票号，从_oldestIndex中得到，数字为1。

            5. 重复第4步，现在差为0，队列中没有其他的票了。

        ##### 方法2/3：enqueue(data)

            对于 enqueue 方法，有两个功能：

            1. 使用_newestIndex 的值作为 this._storage 的键，并使用要添加的数据作为该键的值。

            2. 将_newestIndex 的值增加1。

            基于这两个功能，我们将编写 enqueue(data) 方法的代码：

                ```js
                Queue.prototype.enqueue = function(data) {

                    this._storage[this._newestIndex] = data;

                    this._newestIndex++;

                };
                ```
            该方法的主体只有两行代码。 在第一行，用 this._newestIndex 为this._storage 创建一个新的键，并为其分配数据。 this._newestIndex 始终从1开始。在第二行代码中，我们将 this._newestIndex 的值增加1，将其更新为2。

            以上是方法 enqueue(data) 的所有代码。下面我们来实现方法 dequeue( )。


        ##### 方法2/3：dequeue( )

            以下是此方法的两个功能点：

            - 删除队列中最旧的数据。

            - 属性 _oldestIndex 加1。

                ```js
                Queue.prototype.dequeue = function() {

                    var oldestIndex = this._oldestIndex,

                        deletedData = this._storage[oldestIndex];


                    delete this._storage[oldestIndex];

                    this._oldestIndex++;


                    return deletedData;

                };
                ```
                在 dequeue( )的代码中，我们声明两个变量。 第一个变量 oldestIndex 给 this._oldestIndex 赋值。第二个变量 deletedData 被赋予 this._storage[oldestIndex] 的值。

                下一步，删除队列中最早的索引。之后将 this._oldestIndex 的值加1。最后返回刚刚被删除的数据。

                与栈的 pop() 方法第一次实现中出现的问题类似，dequeue() 在队列中没有数据的情况下不应该被执行。我们需要一些代码来处理这种情况。

                ```js
                Queue.prototype.dequeue = function() {

                    var oldestIndex = this._oldestIndex,

                        newestIndex = this._newestIndex,

                        deletedData;


                    if (oldestIndex !== newestIndex) {

                        deletedData = this._storage[oldestIndex];

                        delete this._storage[oldestIndex];

                        this._oldestIndex++;


                        return deletedData;

                    }

                };
                ```
        - 队列的完整实现代码
            ```js
            function Queue() {

                this._oldestIndex = 1;

                this._newestIndex = 1;

                this._storage = {};

            }


            Queue.prototype.size = function() {

                return this._newestIndex - this._oldestIndex;

            };


            Queue.prototype.enqueue = function(data) {

                this._storage[this._newestIndex] = data;

                this._newestIndex++;

            };


            Queue.prototype.dequeue = function() {

                var oldestIndex = this._oldestIndex,

                    newestIndex = this._newestIndex,

                    deletedData;


                if (oldestIndex !== newestIndex) {

                    deletedData = this._storage[oldestIndex];

                    delete this._storage[oldestIndex];

                    this._oldestIndex++;


                    return deletedData;

                }

            };
            ```

### 单向链表 与 双向链表

- 单链表

    > 在计算机科学中，单链表是一种数据结构，保存了一系列链接的节点。 每个节点中包含数据和一个可指向另一个节点的指针。

    单链列表的节点非常类似于寻宝游戏中的步骤。 每个步骤都包含一条消息（例如“您已到达法国”）和指向下一步骤的指针（例如“访问这些经纬度坐标”）。 当我们开始对这些单独的步骤进行排序并形成一系列步骤时，就是在玩一个寻宝游戏。

    因为单链表包含节点，这两者的构造函数可以是两个独立的构造函数，所以我们需要些构造函数：Node 和 SinglyList

    ##### Node
    - data 存储数据

    - next 指向链表中下一个节点的指针

    ##### SinglyList

    - _length 用于表示链表中的节点数量

    - head 分配一个节点作为链表的头

    - add(value) 向链表中添加一个节点

    - searchNodeAt(position) 找到在列表中指定位置 n 上的节点

    - remove(position) 删除指定位置的节点

        在实现时，我们首先定义一个名为Node的构造函数，然后定义一个名为SinglyList的构造函数。

        Node 的每个实例都应该能够存储数据并且能够指向另外一个节点。 要实现此功能，我们将分别创建两个属性：data和next。

        ```js
        function Node(data) {
            this.data = data;
            this.next = null;
        }

        function SinglyList() {
            this._length = 0;
            this.head = null;
        }
        ```        
    ##### 单链表的方法

    我们需要定义可以从链表中添加、查找和删除节点的方法。先从添加节点开始。

    - 方法1/3: add(value)

        ```js
        SinglyList.prototype.add = function (value) {
            var node = new Node(value)
            var currentNode = this.head
            
            // 第一种情况考虑将节点添加到空的链表中，如果head没有指向任何节点的话，那么将该node指定为链表的头，同时链表的长度加一，并返回node。
            if(!currentNode) {
                this.head = node
                this._length++

                return node
            }

            //  在循环体中，我们将currentNode重新赋值给currentNode.next。 重复这个过程，直到currentNode.next不再指向任何。换句话说，currentNode指向链表中的最后一个节点。
            while(currentNode.next){
                currentNode = currentNode.next
            }

            currentNode.next = node

            this._length ++ 

            return node
        }

        ```

    - 方法2/3: searchNodeAt(position)

        现在我们可以将节点添加到链表中了，但是还没有办法找到特定位置的节点。下面添加这个功能。创建一个名为searchNodeAt(position) 的方法，它接受一个名为 position 的参数。这个参数是个整数，用来表示链表中的位置n。

        ```js
        SinglyList.prototype.searchNodeAt = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 1,
                message = {failure: 'Failure: non-existent node in this list.'};
        
            // 1st use-case: an invalid position 
            if (length === 0 || position < 1 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: a valid position 这个循环不断执行，一直到count等于position。
            while (count < position) {
                currentNode = currentNode.next;
                count++;
            }
        
            return currentNode;
        };
        ```
    - 方法3/3: remove(position)

        ```js
        SinglyList.prototype.remove = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 0,
                message = {failure: 'Failure: non-existent node in this list.'},
                beforeNodeToDelete = null,
                nodeToDelete = null,
                deletedNode = null;
        
            // 1st use-case: an invalid position
            // 无效的位置作为参数传递。
            if (position < 0 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: the first node is removed
            // 第一个位置（链表的的`head）作为参数的传递。
            // 第二种情况处理链表中第一个节点的删除，这也是头节点。 如果是这种情况，就执行下面的逻辑：

            // 头被重新赋值给currentNode.next。
            // deletedNode指向currentNode。
            // currentNode被重新赋值为null。
            // 将的链表的长度减1。
            // 返回deletedNode。
            if (position === 1) {
                this.head = currentNode.next;
                deletedNode = currentNode;
                currentNode = null;
                this._length--;
                
                return deletedNode;
            }
        
            // 3rd use-case: any other node is removed
            // 第三种情况是最难理解的。 其复杂性在于我们要在每一次循环中操作两个节点的必要性。 在每次循环中，需要处理要删除的节点和它前面的节点。当循环到要被删除的位置的节点时，循环终止。
            // beforeNodeToDelete, nodeToDelete, 和 deletedNode。删除nodeToDelete之前，必须先把它的next的值赋给beforeNodeToDelete的next，如果不清楚这一步骤的目的，可以提醒自己有一个节点负责链接其前后的其他节点，只需要删除这个节点，就可以把链表断开。
            while (count < position) {
                beforeNodeToDelete = currentNode;
                nodeToDelete = currentNode.next;
                count++;
            }
        
            beforeNodeToDelete.next = nodeToDelete.next;
            deletedNode = nodeToDelete;
            nodeToDelete = null;
            this._length--;
        
            return deletedNode;
        };
        ```
    ##### 单向链表的完整实现

        ```js
        function Node(data) {
            this.data = data;
            this.next = null;}
        function SinglyList() {
            this._length = 0;
            this.head = null;
        }
        SinglyList.prototype.add = function(value) {
            var node = new Node(value),
                currentNode = this.head;
        
            // 1st use-case: an empty list
            if (!currentNode) {
                this.head = node;
                this._length++;
        
                return node;
            }
        
            // 2nd use-case: a non-empty list
            while (currentNode.next) {
                currentNode = currentNode.next;
            }
        
            currentNode.next = node;
        
            this._length++;
            
            return node;};
        SinglyList.prototype.searchNodeAt = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 1,
                message = {failure: 'Failure: non-existent node in this list.'};
        
            // 1st use-case: an invalid position
            if (length === 0 || position < 1 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: a valid position
            while (count < position) {
                currentNode = currentNode.next;
                count++;
            }
        
            return currentNode;};
        SinglyList.prototype.remove = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 0,
                message = {failure: 'Failure: non-existent node in this list.'},
                beforeNodeToDelete = null,
                nodeToDelete = null,
                deletedNode = null;
        
            // 1st use-case: an invalid position
            if (position < 0 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: the first node is removed
            if (position === 1) {
                this.head = currentNode.next;
                deletedNode = currentNode;
                currentNode = null;
                this._length--;
                
                return deletedNode;
            }
        
            // 3rd use-case: any other node is removed
            while (count < position) {
                beforeNodeToDelete = currentNode;
                nodeToDelete = currentNode.next;
                count++;
            }
        
            beforeNodeToDelete.next = nodeToDelete.next;
            deletedNode = nodeToDelete;
            nodeToDelete = null;
            this._length--;
        
            return deletedNode;
        };
        ```
- 双向链表

    我们已经完整的实现了单链表，这真是极好的。现在可以在一个占用费连续的空间的链表结构中，进行添加、删除和查找节点的操作了。

    然而现在所有的操作都是从链表的起始位置开始，并运行到链表的结尾。换句话说，它们是单向的。

    可能在某些情况下我们希望操作是双向的。如果你考虑了这种可能性，那么你刚才就是描述了一个双向链表。

    ##### 双向链表的操作
    
    - Node 
        - data 存储数据。

        - next 指向链表中下一个节点的指针。
        
        - previous 指向链表中前一个节点的指针。

    - DoublyList

        -  _length 保存链表中节点的个数

        -  head 指定一个节点作为链表的头节点

        -  tail 指定一个节点作为链表的尾节点

        -  add(value) 向链表中添加一个节点

        -  searchNodeAt(position) 找到在列表中指定位置 n 上的节点

        -  remove(position) 删除链表中指定位置上的节点

    - 双向链表的实现

        ```js
        function Node(value) {
            this.data = value;
            this.previous = null;
            this.next = null;
        }

        // 与单链表不同，双向链表包含对链表开头和结尾节点的引用。 由于DoublyList刚被实例化时并不包含任何节点，所以head和tail的默认值都被设置为null。
        function DoublyList() {
            this._length = 0;
            this.head = null;
            this.tail = null;
        }

        ```
    - 双向链表的方法

        ```js
        // 方法1/3 add(value)

        DoublyList.prototype.add = function(value) {
            var node = new Node(value);
        
            // 如果链表中已经存在节点，则查找链表的尾部并把心节点分配给tail.next
            if (this._length) {
                this.tail.next = node;
                node.previous = this.tail;
                this.tail = node;
            } 
            // 如果链表是空的，则给它的head和tail分配节点
            else {
                this.head = node;
                this.tail = node;
            }
        
            this._length++;
            
            return node;
        };

        // 方法2/3 searchNodeAt(position)

        DoublyList.prototype.searchNodeAt = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 1,
                message = {failure: 'Failure: non-existent node in this list.'};
        
            // 1st use-case: an invalid position 
            if (length === 0 || position < 1 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: a valid position 
            while (count < position) {
                currentNode = currentNode.next;
                count++;
            }
        
            return currentNode;
        };

        // 方法3/3 remove(position)

        DoublyList.prototype.remove = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 1,
                message = {failure: 'Failure: non-existent node in this list.'},
                beforeNodeToDelete = null,
                nodeToDelete = null,
                deletedNode = null;
        
            // 1st use-case: an invalid position
            // 如果remove(position)的参数传递的位置存在, 将会抛出一个错误。
            if (length === 0 || position < 1 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: the first node is removed
            // 如果remove(position)的参数传递的位置是链表的第一个节点（head）
            if (position === 1) {
                this.head = currentNode.next;
        
                // 2nd use-case: there is no second node
                if (this.head === undefined || this.head === null) {
                    this.tail = null;
                // 2nd use-case: there is a second node
                } else {
                    this.head.previous = null;
                }
        
            // 3rd use-case: the last node is removed
            } else if (position === this._length) {
                this.tail = this.tail.previous;
                this.tail.next = null;
            // 4th use-case: a middle node is removed
            } else {
                while (count < position) {
                    currentNode = currentNode.next;
                    count++;
                }
        
                beforeNodeToDelete = currentNode.previous;
                nodeToDelete = currentNode;
                afterNodeToDelete = currentNode.next;
        
                beforeNodeToDelete.next = afterNodeToDelete;
                afterNodeToDelete.previous = beforeNodeToDelete;
                deletedNode = nodeToDelete;
                nodeToDelete = null;
            }
        
            this._length--;
        
            return message.success;
        };
        ```

        remove(position) 处理以下四种情况：

        如果remove(position)的参数传递的位置不存在, 将会抛出一个错误。

        如果remove(position)的参数传递的位置是链表的第一个节点（head），将把head赋值给deletedNode，然后把head重新分配到链表中的下一个节点。 此时，我们必须考虑链表中否存在多个节点。 如果答案为否，头部将被分配为null，之后进入if-else语句的if部分。 在if的代码中，还必须将tail设置为null —— 换句话说，我们返回到一个空的双向链表的初始状态。如果删除列表中的第一个节点，并且链表中存在多个节点，那么我们输入if-else语句的else部分。 在这种情况下，我们必须正确地将head的previous属性设置为null —— 在链表的头前面是没有节点的。

        如果remove(position)的参数传递的位置是链表的尾部，首先把tail赋值给deletedNode，然后tail被重新赋值为尾部之前的那个节点，最后新尾部后面没有其他节点，需要将其next值设置为null。

        这里发生了很多事情，所以我将重点关注逻辑，而不是每一行代码。 一旦CurrentNode指向的节点是将要被remove(position)删除的节点时，就退出while循环。这时我们把nodeToDelete之后的节点重新赋值给beforeNodeToDelete.next。相应的， 把nodeToDelete之前的节点重新赋值给afterNodeToDelete.previous。——换句话说，我们把指向已删除节点的指针，改为指向正确的节点。最后，把nodeToDelete赋值为null。

    - 双向链表的完整实现

        ```js
        function Node(value) {
            this.data = value;
            this.previous = null;
            this.next = null;
        }
        function DoublyList() {
            this._length = 0;
            this.head = null;
            this.tail = null;
        }
        DoublyList.prototype.add = function(value) {
            var node = new Node(value);
        
            if (this._length) {
                this.tail.next = node;
                node.previous = this.tail;
                this.tail = node;
            } else {
                this.head = node;
                this.tail = node;
            }
        
            this._length++;
        
            return node;
        };
        DoublyList.prototype.searchNodeAt = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 1,
                message = {failure: 'Failure: non-existent node in this list.'};
        
            // 1st use-case: an invalid position
            if (length === 0 || position < 1 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: a valid position
            while (count < position) {
                currentNode = currentNode.next;
                count++;
            }
        
            return currentNode;
        };
        DoublyList.prototype.remove = function(position) {
            var currentNode = this.head,
                length = this._length,
                count = 1,
                message = {failure: 'Failure: non-existent node in this list.'},
                beforeNodeToDelete = null,
                nodeToDelete = null,
                deletedNode = null;
        
            // 1st use-case: an invalid position
            if (length === 0 || position < 1 || position > length) {
                throw new Error(message.failure);
            }
        
            // 2nd use-case: the first node is removed
            if (position === 1) {
                this.head = currentNode.next;
        
                // 2nd use-case: there is no second node
                if (this.head === undefined || this.head === null) {
                    this.tail = null;
                // 2nd use-case: there is a second node
                } else {
                    this.head.previous = null;
                }
        
            // 3rd use-case: the last node is removed
            } else if (position === this._length) {
                this.tail = this.tail.previous;
                this.tail.next = null;
            // 4th use-case: a middle node is removed
            } else {
                while (count < position) {
                    currentNode = currentNode.next;
                    count++;
                }
        
                beforeNodeToDelete = currentNode.previous;
                nodeToDelete = currentNode;
                afterNodeToDelete = currentNode.next;
        
                beforeNodeToDelete.next = afterNodeToDelete;
                afterNodeToDelete.previous = beforeNodeToDelete;
                deletedNode = nodeToDelete;
                nodeToDelete = null;
            }
        
            this._length--;
        
            return message.success;
        };
        ```

- 树

    ```
    树是 web 开发中最常用的数据结构之一。 这种说法对开发者和用户都是正确的。每个编写HTML的开发者，只要把网页载入浏览器就会创建一个树，树通常被称为文档对象模型（DOM）。相应地，每个在互联网上浏览信息的人，也都是以DOM树的形式接受信息。 每个编写HTML并且将其加载到Web浏览器的Web开发人员都创建了一个树，这被称为文档对象模型（DOM）。互联网上的所有用户，在获取信息时，都是以树的形式收——即DOM。 

    现在，高潮来了：你正在读的本文在浏览器中就是以树的形式进行渲染的。文字由<p>元素进行表示；<p>元素又嵌套在<body>元素中；<body>元素又嵌套在<html>元素中。 您正在阅读的段落表示为<p>元素中的文本；<p>元素嵌套在<body>元素中；<body>元素嵌套在<html>元素中。

    这些嵌套数据和家族数类似。 <html>是父元素，<body>是子元素，<p>又是<body>的子元素 如果这个比喻对你有点用的话，你将会发现在我们介绍树的时候会用到更多的类比。
    ```

    ##### 树（深度搜索和广度搜索）

    由于每个树都包含节点，其可以是来自树的单独构造器，我们将概述两个构造函数的操作：Node和Tree

    - 节点
        - data 存储值。

        - parent 指向节点的父节点。

        - children 指向列表中的下一个节点。

    - 树
        - _root 指向一个树的根节点。

        - traverseDF(callback) 对树进行DFS遍历。

        - traverseBF(callback) 对树进行BFS遍历。

        - contains(data, traversal) 搜索树中的节点。

        - add(data, toData, traverse) 向树中添加节点。

        - remove(child, parent) 移除树中的节点。

    - 实现树

        ```js
        function Node(data) {
            this.data = data;
            this.parent = null;
            this.children = [];
        }

        function Tree(data) {
            var node = new Node(data);
            this._root = node;
        }        

        ```

        - Tree的方法
            接下来我们将要创建以下五种方法。 

        - 树
            traverseDF(callback)

            traverseBF(callback)

            contains(data, traversal)

            add(child, parent)

            remove(node, parent)

            ```js
            // 方法1/5: traverseDF(callback)
            Tree.prototype.traverseDF = function(callback) {
 
                // this is a recurse and immediately-invoking function 
                (function recurse(currentNode) {
                    // step 2
                    for (var i = 0, length = currentNode.children.length; i < length; i++) {
                        // step 3
                        recurse(currentNode.children[i]);
                    }
            
                    // step 4
                    callback(currentNode);
                    
                    // step 1
                })(this._root);
            };


            ```

            traverseDF(callback)有一个参数callback。 如果对这个名字不明白，callback被假定是一个函数，将在后面被traverseDF(callback)调用。

            traverseDF(callback)的函数体含有另一个叫做recurse的函数。 这个函数是一个递归函数！ 换句话说，它是自我调用和自我终止。 使用recurse的注释中提到的步骤，我将描述递归用来recurse整个树的一般过程。

            这里是步骤：

            立即使用树的根节点作为其参数调用recurse。 此时，currentNode指向当前节点。

            进入for循环并且从第一个子节点开始，每一个子节点都迭代一次currentNode函数。

            在for循环体内，使用currentNode的子元素调用递归。 确切的子节点取决于当前for循环的当前迭代。

            当currentNode不存在子节点时，我们退出for循环并callback我们在调用traverseDF（callback）期间传递的回调。

            步骤2（自终止），3（自调用）和4（回调）重复，直到我们遍历树的每个节点。 

            递归是一个非常困难的话题，需要一个完整的文章来充分解释它。由于递归的解释不是本文的重点 —— 重点是实现一棵树 —— 我建议任何读者没有很好地掌握递归做以下两件事。 

            首先，实验我们当前的traverseDF(callback)实现，并尝试一定程度上理解它是如何工作的。 第二，如果你想要我写一篇关于递归的文章，那么请在本文的评论中请求它。 

            以下示例演示如何使用traverseDF(callback)遍历树。要遍历树，我将在下面的示例中创建一个。我现在使用的方法不是罪理想的，但它能很好的工作。 一个更好的方法是使用add(value)，我们将在第4步和第5步中实现。

            ```js
            var tree = new Tree('one');
            tree._root.children.push(new Node('two'));tree._root.children[0].parent = tree;
            tree._root.children.push(new Node('three'));tree._root.children[1].parent = tree;
            tree._root.children.push(new Node('four'));tree._root.children[2].parent = tree;
            tree._root.children[0].children.push(new Node('five'));tree._root.children[0].children[0].parent = tree._root.children[0];
            tree._root.children[0].children.push(new Node('six'));tree._root.children[0].children[1].parent = tree._root.children[0];
            tree._root.children[2].children.push(new Node('seven'));tree._root.children[2].children[0].parent = tree._root.children[2];
            /*
            
            creates this tree
            
            one
            ├── two
            │   ├── five
            │   └── six
            ├── three
            └── four
                └── seven
            
            */

            tree.traverseDF(function(node) {
                console.log(node.data)});
            /*
            
            logs the following strings to the console
            
            'five'
            'six'
            'two'
            'three'
            'seven'
            'four'
            'one'
            
            */
            ```

        - 方法2/5: traverseBF(callback)

            这个方法使用深度优先搜索去遍历树

            深度优先搜索和广度优先搜索之间的差别涉及树的节点访问的序列。 为了说明这一点，让我们使用traverseDF(callback)创建的树。

            ```js
            /* 
                tree
                
                one (depth: 0)
                ├── two (depth: 1)
                │   ├── five (depth: 2)
                │   └── six (depth: 2)
                ├── three (depth: 1)
                └── four (depth: 1)
                    └── seven (depth: 2)
            */


           tree.traverseBF(function(node) {
                console.log(node.data)});
            /*
            
            logs the following strings to the console
            
            'one'
            'two'
            'three'
            'four'
            'five'
            'six'
            'seven'
            
            */
            ```

            来自控制台的日志和我们的树的图显示了关于广度优先搜索的模式。从根节点开始；然后行进一个深度并访问该深度从左到右的每个节点。重复此过程，直到没有更多的深度要移动。 

            由于我们有一个广度优先搜索的概念模型，现在让我们实现使我们的示例工作的代码。 

            ```js
            Tree.prototype.traverseBF = function(callback) {
            var queue = new Queue();
            
            queue.enqueue(this._root);
        
            currentTree = queue.dequeue();
        
            while(currentTree){
                for (var i = 0, length = currentTree.children.length; i < length; i++) {
                    queue.enqueue(currentTree.children[i]);
                }
        
                callback(currentTree);
                currentTree = queue.dequeue();
            }};
            ```

            我们对traverseBF(callback)的定义包含了很多逻辑。 因此，我会用下面的步骤解释这些逻辑：

            创建 Queue的实例。

            调用traverseBF(callback)产生的节点添加到Queue的实例。

            定义一个变量currentNode并且将其值初始化为刚才添加到队列里的node

            当currentNode指向一个节点时，执行wille循环里面的代码。

            用for循环去迭代currentNode的子节点。

            在for循环体内，将每个子元素加入队列。

            获取currentNode并将其作为callback的参数传递。

            将currentNode重新分配给正从队列中删除的节点。

            直到currentNode不再指向任何节点——也就是说树中的每个节点都访问过了——重复4-8步。

        - 方法3/5 contains(callback, traversal)

            ```js
            Tree.prototype.contains = function(callback, traversal) {
            traversal.call(this, callback);};
            ```

            在contains(callback, traversal)函数体内，我们用call方法去传递this和callback。 第一个参数将traversal绑定到被调用的树contains（callback，traversal）；第二个参数是在树中每个节点上调用的函数。

            想象一下，我们要将包含奇数数据的任何节点记录到控制台，并使用BFS遍历树中的每个节点。 我们可以这么写代码：

            ```js
            // tree is an example of a root nodetree.contains(function(node){
            if (node.data === 'two') {
                console.log(node);
            }}, tree.traverseBF);add(data, toData, traversal) 
            ```

        - 方法4/5: add(data, toData, traversal)

            现在有了一个可以搜索树中特定节点的方法。 让我们定义一个允许向指定节点添加节点的方法。

            ```js
            Tree.prototype.add = function(data, toData, traversal) {
            var child = new Node(data),
                parent = null,
                callback = function(node) {
                    if (node.data === toData) {
                        parent = node;
                    }
                };
        
            this.contains(callback, traversal);
        
            if (parent) {
                parent.children.push(child);
                child.parent = parent;
            } else {
                throw new Error('Cannot add node to a non-existent parent.');
            }};
            ```

            add(data, toData, traversal)定义了三个参数。 第一个参数data用来创建一个Node的新实例。 第二个参数toData用来比较树中的每个节点。 第三个参数traversal，是这个方法中用来遍历树的类型。

            在add(data, toData, traversal)函数体内，我们声明了三个变量。 第一个变量child代表初始化的Node实例。 第二个变量parent初始化为null；但是将来会指向匹配toData值的树中的任意节点。parent的重新分配发生在我们声明的第三个变量，这就是callback。

            callback是一个将toData和每一个节点的data属性做比较的函数。 如果if语句的值是true，那么parent将被赋值给if语句中匹配比较的节点。

            每个节点的toData在contains(callback, traversal)中进行比较。遍历类型和callback必须作为contains(callback, traversal)的参数进行传递。

            最后，如果parent不存在于树中，我们将child推入parent.children； 同时也要将parent赋值给child的父级。否则，将抛出错误。

            让我们用add(data, toData, traversal)做个例子：

            ```js
            var tree = new Tree('CEO');
            tree.add('VP of Happiness', 'CEO', tree.traverseBF);
            /*
            
            our tree
            
            'CEO'
            └── 'VP of Happiness'
            
            */

            var tree = new Tree('CEO');
            tree.add('VP of Happiness', 'CEO', tree.traverseBF);tree.add('VP of Finance', 'CEO', tree.traverseBF);tree.add('VP of Sadness', 'CEO', tree.traverseBF);
            tree.add('Director of Puppies', 'VP of Finance', tree.traverseBF);tree.add('Manager of Puppies', 'Director of Puppies', tree.traverseBF);
            /*
            
            tree
            
            'CEO'
            ├── 'VP of Happiness'
            ├── 'VP of Finance'
            │   ├── 'Director of Puppies'
            │   └── 'Manager of Puppies'
            └── 'VP of Sadness'
            
            */
            ```
        - 方法5/5:remove(data, fromData, traversal)

            为了完成Tree的实现，我们将添加一个叫做remove(data, fromData, traversal)的方法。 跟从DOM里面移除节点类似，这个方法将移除一个节点和他的所有子级。

            ```js
            Tree.prototype.remove = function(data, fromData, traversal) {
            var tree = this,
                parent = null,
                childToRemove = null,
                index;
        
            var callback = function(node) {
                if (node.data === fromData) {
                    parent = node;
                }
            };
        
            this.contains(callback, traversal);
        
            if (parent) {
                index = findIndex(parent.children, data);
        
                if (index === undefined) {
                    throw new Error('Node to remove does not exist.');
                } else {
                    childToRemove = parent.children.splice(index, 1);
                }
            } else {
                throw new Error('Parent does not exist.');
            }
        
            return childToRemove;};
            ```
            与add(data, toData, traversal)类似，移除将遍历树以查找包含第二个参数的节点，现在为fromData。 如果这个节点被发现了，那么parent将指向它。

            在这时候，我们到达了第一个if语句。 如果parent不存在，将抛出错误。 如果parent不存在，我们使用parent.children调用findIndex（）和我们要从parent节点的子节点中删除的数据 （findIndex（）是一个帮助方法，我将在下面定义。）

        
            ```js
            function findIndex(arr, data) {
            var index;
        
            for (var i = 0; i < arr.length; i++) {
                if (arr[i].data === data) {
                    index = i;
                }
            }
        
            return index;}
            ```

            在findIndex()里面，以下逻辑将发生。 如果parent.children中的任意一个节点包含匹配data值的数据,那么变量index赋值为一个整数。 如果没有子级的数值属性匹配data，那么index保留他的默认值undefined。 在最后一行的findIndex()方法，我们返回一个index。

            我们现在去remove(data, fromData, traversal)如果index的值是undefined，将会抛出错误。 如果index的值存在，我们用它来拼接我们想从parent的子节点中删除的节点。同样我们给删除的子级赋值为childToRemove。

            最后，我们返回childToRemove。            

    - 树的的完整实现

        ```js
        function Node(data) {
            this.data = data;
            this.parent = null;
            this.children = [];}
        function Tree(data) {
            var node = new Node(data);
            this._root = node;}
        Tree.prototype.traverseDF = function(callback) {
        
            // this is a recurse and immediately-invoking function
            (function recurse(currentNode) {
                // step 2
                for (var i = 0, length = currentNode.children.length; i < length; i++) {
                    // step 3
                    recurse(currentNode.children[i]);
                }
        
                // step 4
                callback(currentNode);
        
                // step 1
            })(this._root);
        };
        Tree.prototype.traverseBF = function(callback) {
            var queue = new Queue();
        
            queue.enqueue(this._root);
        
            currentTree = queue.dequeue();
        
            while(currentTree){
                for (var i = 0, length = currentTree.children.length; i < length; i++) {
                    queue.enqueue(currentTree.children[i]);
                }
        
                callback(currentTree);
                currentTree = queue.dequeue();
            }};
        Tree.prototype.contains = function(callback, traversal) {
            traversal.call(this, callback);};
        Tree.prototype.add = function(data, toData, traversal) {
            var child = new Node(data),
                parent = null,
                callback = function(node) {
                    if (node.data === toData) {
                        parent = node;
                    }
                };
        
            this.contains(callback, traversal);
        
            if (parent) {
                parent.children.push(child);
                child.parent = parent;
            } else {
                throw new Error('Cannot add node to a non-existent parent.');
            }};
        Tree.prototype.remove = function(data, fromData, traversal) {
            var tree = this,
                parent = null,
                childToRemove = null,
                index;
        
            var callback = function(node) {
                if (node.data === fromData) {
                    parent = node;
                }
            };
        
            this.contains(callback, traversal);
        
            if (parent) {
                index = findIndex(parent.children, data);
        
                if (index === undefined) {
                    throw new Error('Node to remove does not exist.');
                } else {
                    childToRemove = parent.children.splice(index, 1);
                }
            } else {
                throw new Error('Parent does not exist.');
            }
        
            return childToRemove;};
        function findIndex(arr, data) {
            var index;
        
            for (var i = 0; i < arr.length; i++) {
                if (arr[i].data === data) {
                    index = i;
                }
            }
        
            return index;}
        ```
