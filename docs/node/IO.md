# IO 

文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有

- 缓冲与非缓冲 I/O

    文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：
        
        - 缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。

        - 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。
    

- 直接与非直接 I/O

    我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。

    - 直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。

    - 非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

    如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？

        - 在调用 write 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；

        - 用户主动调用 sync，内核缓存会刷到磁盘上；

        - 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；

        - 内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；

- 阻塞与非阻塞 I/O VS 同步与异步 I/O

    阻塞 I/O，当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。

    阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程。过程如下：
    ![阻塞io]('../imgs/io-block.webp')