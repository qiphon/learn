# http 协议

- 当我们输入网址后发生了什么
    
    ```
    http 请求模型

    client  -------->   server  --------->  client
            请求（req）           相应(res)
    ```
    1. 输入网址并回车
        - 发送dns包

    2. 解析域名
        - 返回 IP地址

    3. 浏览器发送 http 请求
        - 网关记录请求规则
        - 发出数据包 --> 路由中继 (不定数量) --> server

    4. 服务器处理请求
        - 服务器代理请求，转发到指定位置

    5. 服务器返回（HTML）相应
        - 返回数据包

    6. 浏览器处理（HTML）相应
        - 解析服务器数据包

    7. 继续请求其他资源
        - 

- http 协议详解
    - http是超文本传输协议，从 www 浏览器传输到本地浏览器的一种传输协议，网站是基于 http 协议的
    例如网站的图片、css、js等都是基于 http 协议的
    - http 协议是由 ×客户机到服务器的请求request× 和 ×从服务起到客户机的响应reponse× 进行约束和规范
    
    ```
    http 发展

    http/0.9   ----------  http/1.0  ---------- http/1.1 ---------- http2
    1991                   1996                 1999                2015

    ```
    - TCP/IP 协议栈 （标准 7 层， 实际 5层）

        ```
           标准7层协议                    应用中的5层协议
           --------------------------------------------
               应用层                         应用层
           --------------    
               表示层
           --------------
               会话层
           --------------------------------------------
               传输层                         传输层
           --------------------------------------------
               网络层                         网络层
           --------------------------------------------
              数据链路层                     网络接口层
           ---------------
               物理层
           --------------------------------------------

        ```

        1. 应用层 （应用层、表示层、会话层）
            - 为用户提供所需要的各种服务 ，如 http、ftp、dns、smtp
        2. 传输层（）
            - 该层定义了2个主要的协议：tcp（传输控制协议）、udp（用户数据报协议）
            - 为应用层实体提供端到端的通信功能，保证数据包的顺序传送即数据的完整性
            
        3. 网络层
            - 主要解决主机到主机的通信问题。IP协议是网际互连网层最重要的协议
        
        4. 网络接口层
            - 负责监视数据在主机和网络之间的交换

        - http 在 tcp/ip 协议栈中的位置

        ```
                        http
                            | ssl/tls
            --------------------------
                        tcp
            --------------------------
                        ip
            --------------------------
                     数据链路层

           http 默认端口 80   https 443
        ```

    - http 的工作过程
        - 一次http 操作称为一个事务，其工作可分为 4 步，一旦一个步骤失败，整个事务失败
            1. 客户端与服务器建立连接  tcp 层
            2. 客户机发送一个请求 请求格式（统一资源标识符URL、协议版本号、mime信息）  Http
            3. 服务端处理请求返回响应  http
            4. 显示结果， 客户机与服务器断开连接  tcp
    
    - 请求与响应 
        - http请求组成：请求行（GET /  ）、消息报头、请求正文
        - http响应组成：状态行(HTTP/1.1 200 OK)、消息报头、响应正文
        - 请求行组成：以一个方法符号开头，后面跟着请求的uri 和 协议的版本
        - 状态行组成：服务器http协议的版本，服务器发回的响应状态代码 和 状态代码的文本描述
    
    - 请求
        
        ```
        # 请求

        请求方法           请求URL   http协议及版本
        ----| ------------------|  -------|
        POST /chapter17/user.html  HTTP/1.1
        Accept:
        Referer:
        Accept-Language：                      -------> 报文头
        。。。

        name=1&pwd=2                           ------->报文体
         
        ----------------------------------------------------------------

        
        请求方法 空格 URL 空格 协议版本 回车符换行符    -----> 请求行
        头部字段名：值 回车符换行符                   -----> 请求头
        回车符换行符                            -------> 为了区分头和体
                                                  -----> 请求体

        

        ascii 一个字节代表一个字符  256 个字符

        ```

        - 请求方法（详情可以参考RFC文档）
            - get        请求获取
            - post       在 request-URI 所标识的资源后附加新的数据
            - head       请求获取由 Request-URI所标识的资源的响应消息报头
            - put        请求服务器存储一个资源
            - delete     请求服务器删除
            - trace      请求服务器回送收到的请求信息
            - connect
            - options     请求查询服务器的性能，或者查询与资源相关的选项和需求
            - connect    http/1.1 中预留
        
        - http状态码
            - 1  指示信息  -- 表示请求已接收，继续处理
            - 2  成功     --- 表示请求已被成功接收、理解、接受
            - 3  重定向    -- 要完成请求必须进行更进一步的操作
                - 301 永久重定向 
                - 302 临时重定向 -- 跳转
                - 305 超空间移动  -- 代理
                - 307 临时跳转

            - 4  客户端错误 -- 请求的语法错误或请求无法实现
                - 400 错误请求
                - 402 收费
                - 403 服务器拒绝 
                - 404 找不到
                - 406 请求不接受
                - 408 超时
                - 409 访问冲突
                - 410 资源不见了
                - 413 响应实体过大
                - 417 请求无法满足
                - 418 一个玩笑，茶壶控制协议
                - 420 请求执行失败
                - 422 请求有错误

            - 5  服务端错误 -- 服务器未能实现合法的请求
                - 500 服务器内部错误
        - 请求报头

            ```
            Accept   告诉服务器接受的类型 text/html application/json
            Accept-Encoding  gzip,  是否接受数据压缩
            Accept-Laguage   接受的语言 zh-CN,zh,q=0.9
            Connection    keep-alive (长连接)  
            Host    域名
            Referer  来源，上一个页面是谁，从哪里过来的. 可以用来检查盗链
            User-Agent  浏览器、操作系统信息，用于表明身份
            Cookie

            Content-Encoding    gzip
            Server           服务器使用的是什么
            Cache-Ctrol
            Date
            Expires
            Strict-Transport-Security

            ```
- cookie 与 session
    - cookie 是保存在客户端的一小段文本，随客户端没次请求服务端下发cookie，下次请求浏览器携带cookie到服务器
        - 可以实现免登录
        - 下发  `Set-Cookie: abc=123; path=/; domain=.baidu.com; ` 逐条下发
        - 浏览器端 `document.cookie` 查看修改 cookie
    - session 保存在服务端，由客户端和服务端共同维护
        - 和 cookie 配合使用，保证安全性，更加安全的要和 token 配合（token定时更新）
        - session通过唯一的值 sessionID 来区别每一个用户。sessionID 随每个连接请求发送到服务器
        - 服务器根据 sessionID 来识别客户端，再通过session 的key来获取session 值

- http 缓存 
    - 缓存会根据请求保存输出内容的副本,下一个请求到来的时候，如果是相同的URL，缓存直接使用副本响应
    - 缓存会减少网络延迟，减少带宽消耗
    
    ```
    浏览器请求 --> 无缓存 --> 向web服务器请求 --> 请求响应，协商缓存 --> 显现

    浏览器请求 --> 有缓存 ----------> 是否使用 Etag --------------------------->|
                    |      缓存过期        |        请求携带If-None-Match      |
               没过期|                     |                                 |
                    |             是否使用Last-Modified -------------------->|
                响应缓存                   |         请求携带If-Modified-Since |
                                          |否                                |
                                          |                                 |
                                    请求数据，协商缓存   <-----------------200/304
                                                        无缓存 200           |
                                                                            |
                                                                        304 响应缓存
    

    ```

    - 强制缓存：服务器通知浏览器一个缓存时间，在缓存时间内直接使用缓存内容，超过时间使用比较缓存
    - 比较缓存: 将缓存信息中的Etag 和 Last-Modified 通过请求，发送服务器校验，返回 304 状态码时，直接使用缓存 
        - Etag/if-None-Match (优先)
        - Last-Modified/If-Modified-Since

    - cache-conctrol: max-age=234234  / no-cache
    - expires: 时间对象  （优先级低于 cache-control）
    - pragma : (http1.0产物，现在基本看不到了)
    - 上面是强缓 =============== 下面是比较缓存
    - last-modified / If-Modified-Since （请求时调用）
    - etag / If-None-Match （请求时调用）
    - POST 请求不会被缓存

- 密码学入门
    - 加密就是一种数学算法，涉及到　数论、质数等
    - 密码学的处理对象是 数字 和 字符串
    - 散列是一种数据，一旦转换为其他形式将永远无法回复的加密技术
    - 加密
        - 对称加密　（ＡＥＳ、ＤＥＳ、３ＤＥＳ）加密的秘钥和解密的秘钥相同
        - 非对称加密 （ＲＳＡ）加密的秘钥　（公钥）　和解密　（私钥）　的秘钥不同
    - 秘钥交换算法　（针对的是对称加密）
        - Diffie-Hellman 算法是一种著名的秘钥协商算法，这种算法可以使得信息交换的双方通过公开的非安全的网络
        协商生成安全的共享秘钥
            
            1. Alice 与 bob 确定2个大素数 n 和 g，这2个数不用保密
            2. Alice 选择另一个大随机数 x，并计算 A 如下： A = gx mod n
            3. Alice 将 A 发送给 bob
            4. bob 选择另一个大的随机数 y，并计算 B 如下：B = gy mod n
            5. bob 将 B 发送给 Alice
            6. 计算秘密秘钥K1：  K1 = Bx mod n
            7. 计算秘密秘钥K2：  K2 = Ay mod n
            - K1 = K2，因此 Alice 和 bob 可以用其加解密

- 证书签发机构 （CA）
    - 通过CA发放的证书完成秘钥的交换，实际上是利用非对称的加密算法完成数据加密秘钥的安全交换，
    然后再用数据加密秘钥完成数据的安全交换
    - 数字证书：是互联网通信中标识双方身份的数字文件，由CA签发
    - CA：CA（certification authority）是数字证书的签发机构。作为权威机构，其审核申请者身份后签发数字证书，这样我们只要校验数字证书即可确定对方的身份
    - CA的工作流程

        1. 服务器 qiphon.con 将从 CA 请求 TLS 证书， 例如Digicert
        2. Digicert 将为 qiphon.com 创建证书，证书将包含必要的数据，例如 服务器的名称，服务器的公钥等。
        3. Digicert 创建数据（证书）的哈希值，并使用自己的私钥对其加密
        4. 浏览器和操作系统自带Digicert等权威机构的公钥。
        5. 当浏览器收到签名证书时，他将使用公钥从签名生成哈希值，它还将使用证书中指定的散列算法
        生成数据（证书）的散列，如果2个哈希值匹配，则签名验证成功并且证书是可信的
        6. 现在浏览器可以使用证书中指定的 qiphon.com 的公钥继续进行身份验证过程
        - 在这里，我们可以将 Digicert 称为 root CA

    - 浏览器如何验证证书的有效性
        - 证书颁发机构为服务器创建并签署证书，很少有组织从事这项工作，即Digicert，Geotrust，Comodo等。
        如果他们正在为所有服务器签署证书，则必须为所有签名使用相同的私钥，如果它被盗，那么所有的信任都会丢失。
        为了解决这个问题并增加更多的平均信息量，引入了中间 CA（intermediate CA）的概念
        - 服务器使用中级证书颁发机构的签名，因此在与浏览器通信时，服务器将共享2个证书
            - 包含服务器的公钥，即实际的服务器证书
            - 由 Root CA 颁发的 intermediate CA证书
        - 在签名验证期间，浏览器首先使用已经存在浏览器中的 Root CA的公钥来验证中间证书的数字签名，如果成功，
        浏览器可以信任中间证书及其公钥。现在使用此公钥浏览器将验证原始服务器证书的签名，该组织可以注册为 
        intermediate CA，以便为其域签署证书

- SSL/TLS 协议
    - 传输层安全协议（transport layer security，TSL）及其前身安全套接层（secure sockets layer，SSL）是一种安全协议目的是为互联网通信提供安全及数据完整性保障
    - HTTPS 协议的安全性由 SSL 协议实现，当前使用的TLS协议 1.2 版本，包含 4 个核心子协议：握手协议、秘钥配置切换协议、应用数据协议及报警协议。

        - TLS适用于对称秘钥
        - 对称秘钥可以通过安全秘钥交换算法共享
        - 如果请求被截获，秘钥交换可能被欺骗
        - 使用数字签名进行身份验证
        - 证书颁发机构和信任链
    - https、SSL、TLS、握手协议的关系
        - https是 hypertext transfer protocol over secure socket layer 的缩写，即
        http over SSL，可以理解为基于 SSL 的http协议。https协议的安全是由SSL协议实现的
        - SSL协议是一种记录协议，扩展性好，可以很方便的添加子协议
        - 握手协议是 SSL 的一个子协议
        - TLS 是 SSL 的后续版本

- https 协议分析
    - TLS 握手步骤
        1. client hello： 客户端发送所支持的 SSL/TLS 最高协议版本号和所支持的加密算法集合，以及压缩方法集合等信息给服务器。
        2. server hello：服务器收到信息后，选定双方都支持的 SSL/TLS 协议版本 和加密算法及压缩方法返回客户端
        3. send certificate（可选）：服务器发送自己的证书给客户端
        4. request certificate（可选）：如果选择双向验证，服务器向客户端索要证书
        5. server hello done：服务器通知客户端初始协商结束
        6. response certificate（可选）：如果选择双向验证，客户端发送证书到服务端
        7. client key exchange： 客户端使用服务端的公钥，对客户端公钥和秘钥种子进行加密，发送
        8. certificate verify（可选）：如果选择双向验证，客户端使用本地私钥生成数字签名，发送给服务端，让其通过收到的公钥进行身份验证。
        9. create secret key： 通讯双方基于秘钥种子等信息生成通讯秘钥
        10. change cipher spec：客户端通知服务端已经切换到加密模式
        11. finished ： 客户端做好加密通讯的准备
        12. change cipher spec：服务端通知切换加密模式
        13. finished：服务端standby
        14. encrypted/decryptedData：使用客户端秘钥通过对称加密通讯
        15. closedConnection： 结束通讯后，任何一方发出断开 SSL 连接的消息

        ```
            client                      server
                   1. hello
                ----------------------->
                   2. hello
                <-----------------------
                   3. send certificate
                <----  --- ---  ---  ---
                   4. request certificate
                <---  --  ----  ---  ---
                   5. server done
                <-----------------------
                   6. response certificate
                ---  --  ----  ---  --->
                   7. certificate change
                ----------------------->
                   8. certificate vertify
                ---  --  ----  ---  --->
                   9. 

        ``` 

- http2 协议分析
    - http/2 没有改变 http 的应用语义。http方法、状态代码、uri 和 标头字段等核心概念一如往常
    - http/2 修改了数据格式化（分帧）以及在客户端与服务器间传输的方式。这2点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性
    - 由于 http/2 引入了一个新的二进制分帧层，该层无法与之前的http1.x服务和客户端向后兼容，因此协议的主版本提升到2

    - http2 特点
        - 使用二进制格式传输，更高效、更紧凑
        - 对报头压缩，降低开销
        - 多路复用，一个连接实现并行请求
        - 服务器主动推送，减少请求的延迟
        - 默认使用加密

- http2 二进制分帧层
    - http/2所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 http 消息，并在客户端与服务端之间通信
    - 这里所谓的层，指的是位于套接字接口与应用可见的高级http API 之间一个经过优化的新的编码机制
    - http1.x协议以换行符作为纯文本的分隔符，而 http2将信息分割为更小的消息和帧，采用二进制格式对他们编码
    - 客户机和服务器会为我们完成必要的分帧工作

- http2 多路复用
    - 在http1.x中，如果客户端想要发起多个并行请求以提升性能，则必须用多个tcp/ip 连接。这种模型也会导致队首阻塞造成效率底下
    - 将 http消息分为独立的帧，交错发送，然后在另一端从新组装是http2的另一个增强项。这个机制会在整个网络技术栈中引发一系列的连锁反应，从而带来巨大的性能提升。
        - 并行交错的发送多个请求，请求之间不受影响
        - 并行交错的发送多个响应，响应之间不受干扰
        - 使用一个连接同时发送多个请求和响应
        - 不必再为绕过 http1限制而做很多工作
        - 消除不必要的延迟和提高现有网络容量的利用率，从而减少页面的加载时间

- 服务器推送
    - 服务器可以对客户端请求发送多个响应。除了最初的响应还可以推送额外的资源，无需客户端请求
    - http2 打破了严格的请求-响应语义，支持一对多和服务器发起的工作流
    - 服务器已经知道客户端下一步请求什么，这时候推送可以派上用场
    - 推送资源可以进行一下处理
        - 由客户端缓存
        - 在不同页面间重用
        - 与其他资源一起复用
        - 由服务器设定优先级
        - 被客户端拒绝

- http2 的伪头字段
    - 伪头部字段是 http2内置的几个以 `：`开始的key，用于替代http1中请求行/响应行中的信息，比如请求方法响应状态码等
        - :method 目标URL模式部分（请求）
        - :scheme 目标URL模式部分（请求）
        - :authority 目标 URL 认证部分（请求）
        - :path 目标 URL 的路径和查询部分（绝对路径产生式和一个跟着？的查询产生式）（请求）
        - :status 响应头中的http状态码部分 （响应）

### http3

- 运行在 QUIC （在udp上封装的协议）之上的 http 协议被称为 http/3 （http-over-QUIC）
- QUIC 协议（quick UDP Internet connection）基于 UDP，正式看中了UDP的速度与效率。
同时 QUIC 也整合了 TCP、TLS 和 HTTP2的优点，并加以优化。
- 特点
    - 减少握手的延迟 （1-RTT 或 0-RRT）
    - 多路复用，没有 TCP 的阻塞问题
    - 连接迁移，由 WiFi 切换到 4G 时，连接不断开
- http3 与 http1.1 和 http2 没有直接的关系，也不是 http2 的扩展
- http3 将是一个全新的web协议
- http3 目前处于制定和测试阶段
- https://www.chromium.org/quic


### 队首阻塞问题

- http1.1 和 http2 都存在队首阻塞问题（head of line blocking）
- http1.1 的队首阻塞。一个 tcp 连接同时传输 10个请求，其中第 1,2,3个请求已被客户端接收但是第 4 个丢失，那么第5-10个
请求被阻塞，需要等到第四个请求处理完毕才能被处理，这样就浪费了带宽资源
- http2 的多路复用虽然可以解决“请求”这个粒度的阻塞,但是http2的基础TCP 也存在队首阻塞问题
- 对头阻塞会导致 http2 在更容易丢包的弱网环境下 比 http1 更慢
- QUIC 解决队首阻塞方法
    - QUIC 传输的单元是 packet，加密单元也是packet，整个加密传输解密都基于packet，这样能避免队首阻塞问题
    - QUIC基于 udp，upd的数据包在接收端没有处理顺序，即使中间丢失一个包也不会阻塞整条链路，其他资源也会被正常处理

### http 与 反向代理

- 什么是代理，什么又是反向代理？

```
# 正向代理
------------------------|
client  ---->           |
              \         |
client  ---->     proxy |  --->  server
              /         |
client  ---->           |
------------------------|
局域网

代理功能
- 代理能够记录行为
- 可以记录网站，减少带宽消耗



# 反向代理
                      局域网
                 |----------------------- 
client  ---->    |          --->  server
               \ |        /
client  ---->    | proxy    --->  server
               / |        \
client  ---->    |          --->  server
                 |------------------------

代理功能（比如工厂的向导，把你的需求指向本地的另一个位置）
- 转发请求
- 负载均衡
- 防止内部服务器被工具
- 缓存静态数据
- 加密和 SSL加速
- 压缩
- 减速上传
- 外网发布

```


