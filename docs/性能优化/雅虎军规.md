# 雅虎军规

雅虎军规是现在网络性能优化过程中必须要践行的，这个只是性能优化的基础

- 减少HTTP请求数

    Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。最直接的方式是减少页面所需资源，但并不现实。所以，减少HTTP请求数主要的途径是：

    - 合并JS/CSS文件。服务器端（CDN）自动合并，基于Node.js的文件合并工具，通过把所有脚本放在一个文件中的方式来减少请求数。（一般控制在3-5个）
    - 使用CSS Sprite将背景图片合并成一个文件，通过background-image 和 background-position 控制显示
    - 行内图片（Base64编码）。使用Data URI scheme将图片嵌入HTML或者CSS中；或者将CSS、JS、图片直接嵌入HTML中，会增加文件大小，也可能产生浏览器兼容及其他性能问题。
        
    从减少页面中的 HTTP 请求数量开始。 这是提高首次访问者性能的最重要的指导方针。 正如 Tenni Theurer 的博客所描述的那样，浏览器缓存使用率暴露！ ，40-60% 的每日访问你的网站来与一个空的缓存。 对于这些第一次访问的用户来说，让你的页面更快是获得更好用户体验的关键。

- 减少DNS查询

    用户输入URL以后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20-120毫秒时间。DNS查询完成之前，浏览器无法从服务器下载任何数据。

    基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的DNS缓存机制。

    - IE缓存30分钟，可以通过注册表中DnsCacheTimeout项设置；
    - Firefox缓存1分钟，通过network.dnsCacheExpiration配置；
    - DNS 优化
        ```html
            <meta http-equiv="x-dns-prefetch-control" content="on" />
            <link rel="dns-prefetch" href="blog.qifeng.site" />
            <link rel="dns-prefetch" href="qiphon.blog.csdn.net" />
            ...
        ```


    另外减少不同的主机名可减少DNS查找，减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。

- 避免重定向

    HTTP重定向通过301/302状态码实现。下面是一个有301状态码的HTTP头

    ```http
    HTTP/1.1 301 Moved Permanently 
    Location: http://example.com/newuri
    Content-Type: text/html
    ```

    浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。

    客户端收到服务器的重定向响应后，会根据响应头中Location的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。

    - 如果 URL 中缺少尾部斜线(/) ，就会发生这种情况。 例如，进入 http://astrology.yahoo.com/astrology 地址会导致一个301响应，其中包含一个到 http://astrology.yahoo.com/astrology/ 地址的重定向(注意添加的斜杠)。 在 Apache 中，可以通过使用 Alias 或 mod rewrite 修复这个问题，如果使用 Apache 处理程序，则可以使用 DirectorySlash 指令。

    - 网站域名变更：CNAME结合Alias或mod_rewrite或者其他服务器类似功能实现跳转。

- 缓存Ajax请求

    Ajax 的一个被引用的好处是，它可以向用户提供即时反馈，因为它从后端 web 服务器异步请求信息。 然而，使用 Ajax 并不能保证用户不会无所事事地等待那些 AJAX 回复。 在许多应用程序中，用户是否继续等待取决于如何使用 Ajax。 例如，在基于 web 的电子邮件客户端中，用户将一直等待 Ajax 请求的结果，以查找符合其搜索条件的所有电子邮件消息。 重要的是要记住，“异步”并不意味着“瞬时”。

    - 为了提高性能，优化这些 Ajax 响应非常重要。 提高 Ajax 性能的最重要方法是使响应可缓存，如 Add an Expires 或 Cache-Control Header 中所讨论的。 其他一些规则也适用于 Ajax:

        - Gzip Components
        - Reduce DNS Lookups 减少 DNS 查找
        - Minify JavaScript 缩小 JavaScript
        - Avoid Redirects 避免重定向
        - Configure ETags 配置 ETags

    让我们来看一个例子。 Web 2.0电子邮件客户端可能使用 Ajax 下载用户的地址簿以进行自动完成。 如果用户自上次使用电子邮件 web 应用程序以来没有修改过她的地址簿，那么如果 Ajax 响应可以缓存为未来的 Expires 或 Cache-Control 头，则可以从缓存中读取先前的地址簿响应。 必须告知浏览器何时使用先前缓存的地址簿响应，何时请求新地址簿响应。 这可以通过向地址簿 Ajax URL 添加一个时间戳来实现，例如，添加一个时间戳来指示用户最后一次修改地址簿的时间，& t 1190241612。 如果通讯簿自上次下载以来没有被修改过，时间戳将是相同的，并且通讯簿将从浏览器的缓存中读取，从而消除了额外的 HTTP 往返。 如果用户修改了她的地址簿，时间戳将确保新 URL 与缓存的响应不匹配，并且浏览器将请求更新的地址簿条目。

- 延迟加载

    您可以仔细查看您的页面，然后问自己: “为了最初呈现页面，绝对需要什么? ” . 其余的内容和组件可以等待。

    遵循「渐进增强」理念开发的网站：JavaScript用于增强用用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。

    将首屏以外的HTML放在不渲染的元素中，如隐藏的\<textarea>，或者type属性为非执行脚本的\<script>标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。

- 预加载

    预加载可能看起来像后加载的反义词，但它实际上有一个不同的目标。 通过预加载组件，您可以利用浏览器空闲的时间来请求组件(如图像、样式和脚本)。 这样，当用户访问下一个页面时，您可以在缓存中拥有大多数组件，并且您的页面将为用户加载得更快。

    - 无条件预先加载：页面加载完成（load）后，马上获取其他资源。以 google.com 为例，首页加载完成后会立即下载一个 Sprite 图片，此图首页不需要，但是搜索结果页要用到。
    - 有条件预先加载：根据用户行为预判用户去向，预载相关资源。比如search.yahoo.com开始输入时会有额外的资源加载。Chrome 等浏览器的地址栏也有类似的机制。
    - 有预期的预先加载：页面即将上线新版前预先加载新版内容。网站改版后由于缓存、使用习惯等原因，会有旧版的网站更快更流畅的反馈。为缓解这一问题，在新版上线之前，旧版可以利用空闲提前加载一些新版的资源缓存到客户端，以便新版正式上线后更快的载入。

- 减少DOM元素数量

    一个复杂的页面意味着需要下载更多的字节，同时也意味着 JavaScript 中的 DOM 访问速度变慢。 例如，当需要添加事件处理程序时，如果循环遍历页面上的500或5000个 DOM 元素，则会产生差异。

    Dom 元素的数量很容易测试，只需在 Firebug 的控制台中键入: `document.getElementsByTagName (’ * ’) . length`

    为什么不使用表格布局？

        - 更多的标签，增加文件大小；
        - 不易维护，无法适应响应式设计；
        - 性能考量，默认的表格布局算法会产生大量重绘

- 划分内容到不同域名

    浏览器一般会限制每个域的并行线程（一般为6个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在2-4个域名内，以避免DNS查询损耗。
    
    例如，动态内容放在csspod.com上，静态资源放在static.csspod.com上。这样还可以禁用静态资源域下的Cookie，减少数据传输，详见Cookie 优化。

    [For more information check "Maximizing Parallel Downloads in the Carpool Lane" by Tenni Theurer and Patty Chi.](https://yuiblog.com/blog/2007/04/11/performance-research-part-4/)

- 尽量减少iframe的使用

    用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。
    - \<iframe>的优点：

        - 可以用来加载速度较慢的第三方资源，如广告、徽章；
        - 可用作安全沙箱；
        - 可以并行下载脚本。

    - \<iframe>的缺点：

        - 加载代价昂贵，即使是空的页面；

        - 阻塞页面 load 事件触发；

        - Iframe 完全加载以后，父页面才会触发 load 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe src 可以避免这个问题。

        - 缺乏语义。

- 避免404错误

    - Http 请求是昂贵的，因此发出一个 HTTP 请求并得到一个无用的响应(例如404 Not Found)是完全不必要的，并且会降低用户体验的速度而没有任何好处。
    - 一些网站有很有帮助的404s“你的意思是 x? ” ，这是伟大的用户体验，但也浪费服务器资源(如数据库等)。 特别糟糕的是当链接到外部 JavaScript 是错误的，结果是404。 首先，此下载将阻止并行下载。 接下来，浏览器可能会尝试解析404响应体，就好像它是 JavaScript 代码一样，试图在其中找到可用的内容。

### 服务器方面

- 使用CDN

    > cdn 会找到一台离用户最近的主机，去下载资源

    - 用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？
    - 网站80-90%响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金法则。相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。
    - 内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。

- 添加Expires或Cache-Control响应头

    - 静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；
    - 动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。

    Cache-Control头在HTTP/1.1规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires、Pragma）。当前的所有浏览器都支持Cache-Control，因此，使用它就够了。

- 启用Gzip

    - 前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。
    - Gzip压缩通常可以减少70%的响应大小，对某些文件更可能高达90%，比Deflate更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持gzip解码。所以，应该对HTML、CSS、JS、XML、JSON等文本类型的内容启用压缩。

    注意!!! 图片和 PDF 文件不要使用 gzip。它们本身已经压缩过，再使用 gzip 压缩不仅浪费 CPU 资源，而且还可能增加文件体积。
    
- 配置 Etag

    实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag。
    ```
    HTTP/1.1 200 OK
      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT
      ETag: "10c24bc-4ab-457e1c1f"
      Content-Length: 12195
    ```
    复制代码然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。Etag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 304，避免重新下载。
    ```
    GET /i/yahoo.gif HTTP/1.1
      Host: us.yimg.com
      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT
      If-None-Match: "10c24bc-4ab-457e1c1f"
      HTTP/1.1 304 Not Modified
    ```
- 尽早输出（flush）缓冲  (适合PHP原生开发)

    用户请求页面时，服务器通常需要花费200 ~ 500毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP中的flush()函数，可以发送部分已经准备好的 HTML到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。

    可以考虑在\</head>之后输出一次缓冲，HTML head一般比较容易生成，先发送以便浏览器开始获取\<head>里引用的CSS等资源。
    ```
    Example:
    <!-- css, js -->
    </head>
    <?php flush(); ?>
    <body>
    <!-- content -->
    ```

- Ajax请求使用GET方法

    浏览器执行XMLHttpRequest POST请求时分成两步，先发送Http Header，再发送data。而GET只使用一个TCP数据包（Http Header与data）发送数据，所以首选GET方法。

    根据HTTP规范，GET用于获取数据，POST则用于向服务器发送数据，所以Ajax请求数据时使用GET更符合规范。

- 避免src、href 为空

    图片src属性值为空字符串可能以下面两种形式出现：
    ···html
    <img src="" />

    <!-- JavaScript： -->
    var img = new Image(); 
    img.src = "";
    ```
    虽然src属性为空字符串，但浏览器仍然会向服务器发起一个HTTP请求：

    - IE 向页面所在的目录发送请求；
    - Safari、Chrome、Firefox向页面本身发送请求；
    - Opera不执行任何操作。

    空src产生请求的后果不容小觑：

    - 给服务器造成意外的流量负担，尤其时日 PV 较大时；
    - 浪费服务器计算资源；
    - 可能产生报错。


    空的href属性也存在类似问题。用户点击空链接时，浏览器也会向服务器发送HTTP请求，可以通过JavaScript阻止空链接的默认的行为。

### cookie

- 减少 Cookie 大小

    Cookie被用于身份认证、个性化设置等诸多用途。Cookie通过HTTP头在服务器和浏览器间来回传送，减少Cookie大小可以降低其对响应速度的影响。

    - 去除不必要的 Cookie；
    - 尽量压缩 Cookie 大小；
    - 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；
    - 设置合适的过期时间。

- 静态资源使用无Cookie域名

    静态资源一般无需使用Cookie，可以把它们放在使用二级域名或者专门域名的无Cookie服务器上，降低Cookie传送的造成的流量浪费，提高响应速度。

### css 

- 把样式表放在\<head>中

    把样式表放在\<head>中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。
    这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。
    如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。把样式表放到文档的HEAD部分能让页面看起来加载地更快。

- 不要使用CSS表达式 

    CSS表达式可以在CSS里执行JavaScript，仅IE5-IE7支持，IE8标准模式已经废弃。 CSS表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。

- 使用用\<link>替代@import

    对于IE某些版本，@import的行为和放在页面底部一样。所以，不要用它。

- 不要使用 filter

    AlphaImageLoader为IE5.5-IE8专有的技术，和CSS表达式一样，放进博物馆吧。IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。

    `注意！！！这里所说的不是 CSS3 Filter`

### Javasript

- 把脚本放在页面底部

    浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。

    一些特殊场景无法将脚本放到页面底部的，可以考虑\<script>的以下属性：

    - defer 属性；
    - HTML5 新增的async属性。

- 去除重复脚本

    页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。

    IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。

    　　除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。

    　　避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签：

    `<script type="text/javascript" src="menu_1.0.17.js"></script>`

- 尽量减少DOM访问

    用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：

    - 缓存已访问过的元素的索引
    - 先“离线”更新节点，再把它们添到DOM树上
    - 避免用JavaScript修复布局问题

- 智能事件处理

    有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。

    - 使用事件代理
    - 事件写在 DOMContentLoaded 里面，不要写在 onload 里面

### 图片

- 图片优化

    尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。

    - https://imageoptim.com/api
    - https://github.com/imagemin/imagemin
    - PNG 优化 
        - https://www.queness.com/post/2507/most-effective-method-to-reduce-and-optimize-png-images
        - https://www.smashingmagazine.com/2009/07/clever-png-optimization-techniques/
    - Webp 相关内容；
    - SVG 相关内容。

- 优化CSS Sprite

    - 水平排列Sprite中的图片，垂直排列会增加图片大小；
    - Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以适用PNG8格式；
    - 不要在Spirite的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。

- 不要在HTML中缩放图片 

    - 不要使用<img>的width、height缩放图片，如果用到小图片，就使用相应大小的图片。如果需要
    `<img width="100" height="100" src="mycat.jpg" alt="My Cat" />`
    那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。

    很多 CMS 和 CDN 都提供图片裁切功能。

    补充：设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。

- 使用体积小、可缓存的favicon.ico

    Favicon.ico一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。

    所以确保这个图标：

    - 存在（避免 404）；
    - 尽量小，最好小于 1K；
    - 设置较长的过期时间。
    - 对于较新的浏览器，可以使用PNG格式的favicon。    

### 移动端

- 保证所有组件都小于25K

    这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。

- 把组件打包到一个复合文档里

    把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。

    这种技术比较老了，现在基本不使用了(测试没有成功。。。)


