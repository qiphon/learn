# 浏览器的渲染过程

### 现在浏览器的进化

- 

### 现在浏览器的特征

- 网络
- 资源管理
- 网页浏览
- 多页面管理
- 插件和扩展
- 账户和同步
- 安全机制
- 开发者工具

### 现在浏览器的结构

- 用户界面（user Interface）
- 浏览器引擎（browser Engine）
- 渲染引擎（Rendering Engine）
- 网络（netWorking）
- XML解析器（XML Parser） HTML是XML的子集，XML是HTML的超集
- 显示后端（display backend） 各种功能构件，如 button
- 数据持久层（Data Persistence） cookie、证书、缓存。。。。

### 渲染引擎

- trident  IE
- Gecko   Firefox
- webkit   Safari
- Blink    Chromium/chrome/opera/Edge

### 渲染引擎结构及工作流程

以 HTML、js、css 等文件作为输入，可以可视化内容作为输入

```
                黑盒
             ---------------------------------------------------------------------------------------------------
HTML        |      parsing Html                 Render Tree              layout of                 Painting     |
js   -----> |      to construct      --->     Construction      ------>  Render Tree     ------>  Render Tree   | ---> Display  
css         |      DOM Tre                   解析css                      把每个像素点的位置          渲染样式       |   GPU 开始处理
            |     html 对象化，形成树结构        把css 规则附着到 dom树         预先计算出来                           | 
|           -----------------------------------------------------------------------------------------------------       
|                                                                  |
|                             css                                  |      layout
|                      ↱---->  parser---->↘                       |        ↕
↳→→→→→→→→ →→→ HTML                 ↘                        |        ↕
                    parser--> dom tree -->render Tree    <------------------↕
                    |         ⇅          ↗              <--------------------------------------->
                    ↳ ----> js          ↗                         |                             ↕
                            interperter                            |                             ↕
                                                                                                 painting  -----------> display

```

- dom 规范 w3.org/DOM/
- 要想做优化必须了解底层内容
    - https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html
    - https://dom.spec.whatwg.org/
    - https://html.spec.whatwg.org/multipage/parsing.html

### chrome 架构

- browser： 控制程序的 ‘chrome’ 部分，包括地址栏、书签、后退和前进。还处理浏览器不可见部分和特权部分例如网络请求和文件访问
    - 和 IO、展示相关的都在主进程里，

- renderer：负责显示网站的选项卡内的所有内容

- plugin：控制网站使用的所有插件，例如 flash

- GPU：独立于其他进程的GPU处理任务。他被分成多个不同的进程，因为 GPU 处理来自多个程序的请求，并将他们绘制在同一个页面中

### 渲染进程

- 渲染器进程负责选项卡内发生的所有事情。在渲染进程中，主线程处理你为用户编写的大部分代码
- 如果使用了web worker、service worker，有时js代码的一部分将有工作线程处理，排版和格栅线程也在渲染器进程内运行，以便高效流畅的运行页面


### chrome渲染-解析部分

- 构建 DOM
- 子资源加载
    - 注意 js 可以 阻止解析
- 提示浏览器如何加载资源
- 样式表计算
- 布局
- 绘制

### 渲染过程-合成部分

- 把文档的结构、元素的样式、几何形状和绘制顺序转换为屏幕上的像素成为光栅化
- 合成是一种将页面各个部分分层，分别光栅化，并在一个被称为合成器的线程的独立线程中合成为页面的技术

### 渲染过程-GPU渲染

- 一旦创建了层树并确定了绘制顺序，主线程就将信息提交给合成器线程。合成器线程然后格栅化每个图层，一个图层可能像整个页面长度一样大，
因此合成器线程会将他们分成图块，并把每个图块发送到光栅线程，栅格线程栅格化每一个tile，并将他们存储在 GPU内存中
- 通过 ICP 将合成帧交给浏览器进程，这时可以从UI线程添加另一个合成器，以用于浏览器UI修改，或者从其他渲染进程添加扩充数据。
这些合成帧发送到GPU，用来在屏幕上显示。如果发生滚动事件，合成器线程会创建另一个合成器帧并发送到 GPU
- 合成的好处是他可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或js执行。这就是合成动画是平滑性能的最佳选择，
如果需要再次计算布局或绘图，则必须涉及主线程



