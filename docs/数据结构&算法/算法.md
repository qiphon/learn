# 算法

### 什么是算法？

算法是完成某个特定任务的过程。通常数据结构作为工具来辅助执行算法。所以有一个
广为流传的公式：程序 = 数据结构 + 算法

- 算法不是数学，但是可以用数学来描述
- 我们要做的事情，这个过程本身就是一个算法
- 我们最常用的增删改查是算法的一部分
- 算法可以用自然语言、流程图、伪代码和计算机语言等手段来表示
- 在面向对象语言中，算法通常通过类的方法实现

- 每天都在接触的算法
    - 排序算法
    - 查找算法
    - 推荐算法
    - 贪心算法

### 算法的特征

- 有穷性： 算法必须能在执行有限个步骤之后终止
- 确切性：每一步骤必须有确切的定义
- 输入项：有 0 个或多个输入，用来规定初始情况，所谓 0 个就是输入是指算法本身定出了初始条件
- 输出项：有一个或多个输出，是对输入数据处理后的结果。没有输出的算法毫无意义
- 可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，每个计算步都可以在有限的时间内完成（也称之为有效性）

### 怎样衡量算法的好坏

- 算法的好坏主要通过算法复杂度来衡量

    - 时间复杂度（效率）
        
        基本操作步骤，要执行的次数（不依赖具体硬件和执行环境）

    - 空间复杂度（占用额外的内存空间）

- 正确性
- 可读性
- 健壮性（容错是不是很好）

#### 复杂度 (由上到下依次增高)

- 常数阶O（1）
- 对数阶O(logN)
- 线性阶O（n）
- 线性对数阶O（nlogN）
- 平方阶O（n^2）
- 立方阶O（n^3）
- k次方阶O（n^k）
- 指数阶 O（2^n）

#### 计算算法复查度

- 随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越低
- 一般算法复杂度分析的时候，遵循下面的技巧
    - 有几重循环，一般来说一重就是 O（n），两重就是 O（n^2），以此类推
    - 如果有二分，则为 O（logN）
    - 保留最高项，去除常数项

    ```js
    let i =0         // 执行 1 次
    while(i < n){    // 执行 n 次
        console.log(i) // 执行 n 次
        i++           // n 次
    }
    // 结果 1+ n + n + n = 1 + 3n
    // 取出常数项 O(n)

    let number = 1  // 1
    while(number < n) {       // logN 
        number*= 2    // logN
    }

    // 所以结果 O(logN)

    for(let i = 0; i< n; i++){     // n
        for(let j=0; j< n; j++){    // n^2
            console.log('for')      // n^2
        }
    }

    // 结果 O（n^2）

    ```

### 基本算法

- 枚举
- 递归
- 基本排序
- 基本查找

#### 枚举

- 核心思想：枚举出所有可能
- 本质： 就是从所有候选答案中去搜索正确的解，使用该算法需要满足2个条件
    - 预知候选结果数量
    - 候选答案的范围在求解之前必须有一个特定的集合

- 特点：
    - 枚举算法简单粗暴，暴力枚举所有可能，尽可能地尝试所有方法
    - 速度可能很慢，却是我们最应该优先考虑的
    - 实现最简单，并且得到的结果总是正确的

#### 递归

- 核心思想：通过重复将问题分解为同类的子问题而解决问题的方法
- 特点： 
    - 函数可以通过调用自身来进行递归
    - 递归可以完全取代循环（循环和递归执行的结果对等，基本可以相互转换）

- 递归由2部分组成
    - 递归主体，就是循环解决问题的代码
    - 递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出。

#### 排序算法

- 冒泡     最佳时间 n  平均时间 n^2  最差时间复杂度 n^2  空间复杂度 1  稳定 yes
- 插入     最佳时间 n  平均时间 n^2  最差时间复杂度 n^2  空间复杂度 1  稳定 yes
- 选择     最佳时间 n^2  平均时间 n^2  最差时间复杂度 n^2  空间复杂度 1  稳定 no
- 二叉树   最佳时间 nlogn  平均时间 nlogn  最差时间复杂度 nlogn  空间复杂度 1  稳定 yes
- 快速排序  最佳时间 nlogn  平均时间 nlogn  最差时间复杂度 n^2  空间复杂度 logn ~ n  稳定 no
- 堆排序   最佳时间 nlogn  平均时间 nlogn  最差时间复杂度 nlogn  空间复杂度 1  稳定 no
- 快速排序  最佳时间 nlogn  平均时间 nlogn  最差时间复杂度 n^2  空间复杂度 1  稳定 no

稳定性：得到的结果顺序不能保证每次都是一致的，比如排序一个班级内学生的年龄（从小到大），由于年龄可能相同
所有同年龄的人可能第一次小张在前面，第二次小王在前面

### 怎样养成算法思维

- 结果是什么？
- 步骤是什么？
- 判断结果的标准是什么？

- 化繁为简
    - 很难在第一时间内得到正确的思路，这时候可以尝试一种由简至繁的思路。首先把问题规模缩小到非常容易解答的地步。
    用来解决动态规划问题
    - 分治
        - 把问题分为两半，变成2个与原来问题同构的问题
        - 在尝试这种思路时，其实只需要考虑2个问题：
            - 一分为二以后，问题是否被简化了
            - 根据一分为二的两个问题的解，能否方便地得出整个问题的解

    - 化虚为实
        - 使用另外一种形式进行替换

### 解决算法面试问题

- 面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，挺好关键词，比如： 有序的数列做查找、要求算法复杂度是O（logN）
这类一般就是二分的思想
- 算法题目的解题思路分为一下四步：
    - 先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤
    - 根据解题步骤编写程序，优先将特殊情况做好判读处理，比如一个大数组的问题，如果数组为两个数长度的情况
    - 检验程序的正确性
    - 是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以提现技术能力