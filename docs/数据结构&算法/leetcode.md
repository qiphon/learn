# leetcode 刷题指南

- 算法中的计算机原理（位运算）
- 双指针技巧
- 递归思想
- 广度优先与深度优先（树结构）
- 常见的算法范式
    - 暴力法
    - 分治法
    - 回溯算法
    - 动态规划
    - 贪心算法
    - 分支界限法


##### 位运算

- 复习二进制位运算

```
运算符	           用法	    描述
按位与（ AND）  	a & b	对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。
按位或（OR）	    a | b	对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。
按位异或（XOR） 	a ^ b	对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。
按位非（NOT）	    ~ a	    反转操作数的比特位，即0变成1，1变成0。
左移（Left shift）	a << b	将 a 的二进制形式向左移 b (< 32) 比特位，右边用0填充。
有符号右移	        a >> b	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。
无符号右移	        a >>> b	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。
```

```js
5 ---> 101
6 ---> 110
7 ---> 111
8 ---> 1000

// 判断奇偶数
5&1  true
6&1  false

// 2 的 n 次方，或乘 2 的 n 次方可以使用移位
2 << 2   // 8

使用~, >>, <<, >>>, |来取整

console.log(~~ 6.83)    // 6
console.log(6.83 >> 0)  // 6
console.log(6.83 << 0)  // 6
console.log(6.83 | 0)   // 6
// >>>不可对负数取整
console.log(6.83 >>> 0)   // 6


```

#### 双指针

双指针技巧还可以分为2类，一类是 【快慢指针】，另一类是【左右指针】。
前者主要解决链表中的问题。比如典型的判定链表中是否有环；
后者主要解决数组（或者字符串）中的问题，比如二分查找

- 快慢指针常见算法

    快慢指针一般都初始化指向

- 滑动窗口算法

    滑动窗口法，也叫尺取法，可以用来解决一些查找满足一定条件的连续区间的性质（长度等问题）。
    由于区间连续，因此当区间发生变化时，可以通过旧有点计算结果对搜索空间进行剪枝，这样便
    减少了重复计算，降低了时间复杂度。往往类似于”请找到满足xx的最x区间（子串、子数组）
    的 xx“ 类似问题，都可以用这种算法

    - 无重复字符串的最长子串
    - 最小覆盖子串
    - 长度最小的子数组
    - 最大连续个数

### 最常见的算法范式

- 算法： 按步骤解决问题的过程
- 范式：思考问题的模式
- 算法范式：为问题构建高效解决方案的常规方法

    算法范式可以被看作为解决一类问题的高层算法。

    - 算法范式提供的模板可以适用解决更广泛的问题
    - 通过高层的语言可以将范式转换成通用的组件或数据结构
    - 对算法产生结果所需的空间和空间的需求可以做精确的分析

#### 暴力破解法

暴力破解法简单直接，根据问题声明的定义，找到所有可变化因子（Divisor）,穷举所有可能解决
问题的方法，逐个尝试

所以根据暴力破解法的定义，理论上任何问题都可以通过暴力破解法来解决，只是在实际应用中算法
对时间和空间的需求则无法满足。

线性查找有很多典型应用：
    - 选择排序 selection sort
    - 冒泡排序 bubble sort
    - 顺序查找 sequential search
    - 暴力字符串匹配 native string match

#### 分治法

分治法，即分而治之，是将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些
问题，然后再合并其结果，以得到原问题的解

当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。这些规模变小后的问题和
原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题，规模变小后的
问题是原问题的子问题

分治模式在每一层上都有三个步骤：

- 分解：将原问题分解成一系列与原问题同质的子问题
- 解决：递归地解决各个子问题。若子问题足够小，则直接求解
- 合并：将子问题的结果合并成原问题的解

分治法所能解决的问题一般具有以下特征：

- 可以讲问题分解为若干个规模较小的相同问题
- 问题的规模缩小到一定程度后就可以很容易的解决
- 问题分解出的子问题的解可以合并为该问题的解
- 问题所分解出的各个子问题是相互独立的，即子问题之间不再包含公共的孙问题

符合 123 调节的特征是使用分治法的关键，而特征 4 将涉及到分治法的效率问题。
如果不符合 3,4 特征的问题可以尝试考虑使用动态规划或贪心算法来解决


#### 动态规划法

动态规划的过程可以描述为多阶段最优化解决问题的过程，每一次的决策依赖当前的状态，
随即又引起状态的转移，以此类推在变化的状态中产生的决策序列

动态规划可以找到全局最优解

#### 贪心算法

可以找到局部最优解

所谓贪心算法是指在问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优上
加以考虑，他所做出的仅是在某种意义上局部最优解

贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。贪心策略适用的前提是：
局部最优策略能导致产生全局最优最优解。所以实际上贪心算法适用的情况很少

贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效应，即某个状态
以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析
其是否满足无后效应。

贪心算法的基本思路：

- 建立数学模型来描述问题
- 把求解的问题分成若干个子问题。
- 对于每一个子问题求解，得到子问题的局部最优解
- 把子问题的解局部最优解合成原来问题的一个解

#### 回溯法

回溯法描述了一种选优搜索的过程，按选优条件向前搜索，以达到目标。但当探索到某一步时，
发现原先的原则并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的方法称为
回溯法，而慢走回溯条件的某个状态的点称为”回溯点“

回溯法可以理解为隐式的深度优先搜索算法。其在包含问题的所有解的空间树中，按照深度优先
搜索的策略

#### 分支界限法

类似于回溯法，分支界限法也是一种在问题的空间树上搜索问题解的算法。在一般情况下，分支界限
法与回溯法的求解目标不同。


- [leetcode](https://leetcode-cn.com/problemset/all/)

    - 先刷简单 - 中等 - 困难
    - 分类别刷题 数组 - 字符串 - 哈希表（偏应用）- 堆 - 动态规划 - 
    数学（基础题）- 树 （拔尖） 

    - 熟悉基本数据结构算法、常见衍生数据结构
    - 算法技巧、算法范式（分治最重要，要最先理解）
    - 审题、迅速想一个暴力法解决问题、想一下哪一个过程拖慢了性能