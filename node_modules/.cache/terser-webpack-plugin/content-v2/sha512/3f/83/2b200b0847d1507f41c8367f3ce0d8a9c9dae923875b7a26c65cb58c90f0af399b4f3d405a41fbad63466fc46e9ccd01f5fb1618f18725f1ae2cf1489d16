{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{284:function(n,t,e){\"use strict\";e.r(t);var o=e(38),r=Object(o.a)({},function(){var n=this.$createElement,t=this._self._c||n;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":this.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"php-与-js-在面向对象中的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#php-与-js-在面向对象中的区别\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" php 与 js 在面向对象中的区别\")]),this._v(\" \"),t(\"ol\",[t(\"li\",[this._v(\"construct\")])]),this._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[this._v(\"// php 中的class有construct；es5中的类是用function实现的，并没有见到construct。\\n\\nfunction Car(){\\n    console.log('在实例化的时候我就被执行了');\\n}\\nvar a = new Car();\\n\\n// __construct 在实例化的时候会被执行，其他代码没有被执行\\n\\n<?php\\nheader(\\\"content-type: text/html; charset=utf-8;\\\");\\nclass Car {\\n    public function __construct($name)\\n    {\\n        echo '实例化的时候，我被执行';\\n        echo '<br>';\\n        $this->name = $name;\\n    }\\n    public function test()\\n    {\\n        echo '我没有被执行';\\n        echo '<br>';\\n    }\\n    public function __destruct()\\n    {   // 这个函数每当触发这个类都会被执行\\n        echo '__destruct 最后被执行';\\n        echo '<br>';\\n    }\\n}\\n\\n$c = new Car('c');\\n\\n// js 的function 在实例化的时候,里面所有的代码就会被执行一遍\\nfunction Car(name){\\n    this.name = name;\\n    document.querySelector('body').style.backgroundColor = 'red'\\n}\\nvar c = new Car('c')\\n\\n// 我们会在控制台看到如下信息\\n\\nCar {name: \\\"c\\\"}\\nname: \\\"c\\\"\\n__proto__:\\nconstructor: ƒ Car(name)\\n__proto__: Object   // js 的继承是原型链继承，所有方法和类的根 __proto__ 都指向object\\n\\n// 还用上面的例子， js中所有的方法都挂载在原型链上\\nfunction Car(name){\\n    this.name = name;\\n}\\nCar.prototype.run = function(){\\n    console.log(this.name + ' is run')\\n}\\nvar c = new Car('c')\\n\\n\\n// js中继承的实现\\nfunction Car(name){\\n    this.name = name;\\n}\\nCar.prototype.run = function(){\\n    console.log(this.name + ' is run')\\n}\\n// var c = new Car('c')\\nfunction B(name){\\n    Car.call(this, name);  // 这样属性就会被复制过来了\\n}\\n\\nvar __proto = Object.create(Car.prototype) // 这样就能拿到 car的所有方法，但是我们不能直接将他赋值给B，因为它的constructor 还是Car\\n__proto.constructor = B;  // 手动改变构造器，这样就能为我们所用了,只有构造器是自己了，方法中的this才能转过来\\nB.prototype = __proto;\\nB.prototype.action = function(){\\n    console.log(this.name + ' action')\\n}\\nvar b = new B('b')\\n\\n\")])])])])},[],!1,null,null,null);t.default=r.exports}}]);","extractedComments":[]}